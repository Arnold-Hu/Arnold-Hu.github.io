<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习 感悟 精炼 内化"><title>leetcode记（持续更新中） | 巴别塔</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leetcode记（持续更新中）</h1><a id="logo" href="/.">巴别塔</a><p class="description">每天搭块砖～ 每天向上爬～</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/timeline/"><i class="fa fa-archive"> timeline</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">leetcode记（持续更新中）</h1><div class="post-meta">Feb 29, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/02/29/leetcode记/" href="/2016/02/29/leetcode记/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#No-292-Nim-game"><span class="toc-number">1.</span> <span class="toc-text">No.292 Nim game</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-136-Single-Number"><span class="toc-number">2.</span> <span class="toc-text">No.136 Single Number</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-258-Add-Digits"><span class="toc-number">3.</span> <span class="toc-text">No.258 Add Digits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-104-Maximun-Depth-of-Binary-Tree"><span class="toc-number">4.</span> <span class="toc-text">No.104 Maximun Depth of Binary Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-226-Invert-Binary-Tree"><span class="toc-number">5.</span> <span class="toc-text">No.226 Invert Binary Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-237-Delete-Node-in-a-Linked-List"><span class="toc-number">6.</span> <span class="toc-text">No.237 Delete Node in a Linked List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-283-Move-Zeros"><span class="toc-number">7.</span> <span class="toc-text">No.283 Move Zeros</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-100-Same-Tree"><span class="toc-number">8.</span> <span class="toc-text">No.100 Same Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-260-Single-Number-3"><span class="toc-number">9.</span> <span class="toc-text">No.260 Single Number 3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-238-Product-of-Array-Except-Self"><span class="toc-number">10.</span> <span class="toc-text">No.238 Product of Array Except Self</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-242-Valid-Anagram"><span class="toc-number">11.</span> <span class="toc-text">No.242 Valid Anagram</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-171-Excel-Sheet-Column-Number"><span class="toc-number">12.</span> <span class="toc-text">No.171 Excel Sheet Column Number</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-217-Contains-Duplicate"><span class="toc-number">13.</span> <span class="toc-text">No.217 Contains Duplicate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-169-Majority-Element"><span class="toc-number">14.</span> <span class="toc-text">No.169 Majority Element</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-268-Missing-Number"><span class="toc-number">15.</span> <span class="toc-text">No.268 Missing Number</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-144-Binary-Tree-Preorder-Traversal"><span class="toc-number">16.</span> <span class="toc-text">No.144 Binary Tree Preorder Traversal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-94-Binary-Tree-Inorder-Traversal"><span class="toc-number">17.</span> <span class="toc-text">No.94 Binary Tree Inorder Traversal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-145-Binary-Tree-Postorder-Traversal"><span class="toc-number">18.</span> <span class="toc-text">No.145 Binary Tree Postorder Traversal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-206-Reverse-Linked-List"><span class="toc-number">19.</span> <span class="toc-text">No.206 Reverse Linked List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">20.</span> <span class="toc-text">No.235 Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-191-Number-of-1-Bits"><span class="toc-number">21.</span> <span class="toc-text">No.191 Number of 1 Bits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-328-Odd-Even-Linked-List"><span class="toc-number">22.</span> <span class="toc-text">No.328 Odd Even Linked List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-137-Single-Number-2"><span class="toc-number">23.</span> <span class="toc-text">No.137 Single Number 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-96-Unique-Binary-Search-Trees"><span class="toc-number">24.</span> <span class="toc-text">No.96 Unique Binary Search Trees</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-141-Linked-List-Cycle"><span class="toc-number">25.</span> <span class="toc-text">No.141 Linked List Cycle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-35-Search-Insert-Position"><span class="toc-number">26.</span> <span class="toc-text">No.35 Search Insert Position</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="toc-number">27.</span> <span class="toc-text">No.108 Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-116-Populating-Next-Right-Pointers-in-Each-Node"><span class="toc-number">28.</span> <span class="toc-text">No.116 Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-230-Kth-Smallest-Element-in-a-BST"><span class="toc-number">29.</span> <span class="toc-text">No.230 Kth Smallest Element in a BST</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-83-Remove-Duplicates-from-Sorted-List"><span class="toc-number">30.</span> <span class="toc-text">No.83 Remove Duplicates from Sorted List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-70-Climbing-Stairs"><span class="toc-number">31.</span> <span class="toc-text">No.70 Climbing Stairs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-53-Maximum-Subarray"><span class="toc-number">32.</span> <span class="toc-text">No.53 Maximum Subarray</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-263-Ugly-Number"><span class="toc-number">33.</span> <span class="toc-text">No.263 Ugly Number</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-202-Happy-Number"><span class="toc-number">34.</span> <span class="toc-text">No.202 Happy Number</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-326-Power-of-Three"><span class="toc-number">35.</span> <span class="toc-text">No.326 Power of Three</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-89-Gray-Code"><span class="toc-number">36.</span> <span class="toc-text">No.89 Gray Code</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-62-Unique-Paths"><span class="toc-number">37.</span> <span class="toc-text">No.62 Unique Paths</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-153-Find-Minimum-in-Rotated-Sorted-Array"><span class="toc-number">38.</span> <span class="toc-text">No.153 Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-21-Merge-Two-Sorted-Lists"><span class="toc-number">39.</span> <span class="toc-text">No.21 Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-46-Permutations"><span class="toc-number">40.</span> <span class="toc-text">No.46 Permutations</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-24-Swap-Nodes-in-Pairs"><span class="toc-number">41.</span> <span class="toc-text">No.24 Swap Nodes in Pairs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#No-216-Combination-Sum-3"><span class="toc-number">42.</span> <span class="toc-text">No.216 Combination Sum 3</span></a></li></ol></div></div><div class="post-content"><p>This is a personal answers of leetcode problem. My aim is to find the fast way to solve the problems by python. In some cases, the time or space complexity may be sacrificed. All the problems sorted by AC rate.</p>
<h1 id="No-292-Nim-game"><a href="#No-292-Nim-game" class="headerlink" title="No.292 Nim game"></a>No.292 <a href="https://leetcode.com/problems/nim-game/" target="_blank" rel="external">Nim game</a></h1><blockquote>
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.<br>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.<br>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
</blockquote>
<p>The introduction leaks the most important hint that if there are 4 stones left and you are the first, you will never win. So, our aim is to let the opponent to face this situation. Obviously, if you are the first and can not make the number of left stones as 4n, you must lose. This is a math problem and code is nonsence.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h1 id="No-136-Single-Number"><a href="#No-136-Single-Number" class="headerlink" title="No.136 Single Number"></a>No.136 <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">Single Number</a></h1><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
</blockquote>
<p>Very common problem, set function is a very simple solution of these kind of problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(set(nums))*<span class="number">2</span>-sum(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-258-Add-Digits"><a href="#No-258-Add-Digits" class="headerlink" title="No.258 Add Digits"></a>No.258 <a href="https://leetcode.com/problems/add-digits/" target="_blank" rel="external">Add Digits</a></h1><blockquote>
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
</blockquote>
<p>Python flexible str and list function will solve the problem　concisely.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(list(str(num))) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(map(int,list(str(num))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.addDigits(sum(map(int,list(str(num)))))</span><br></pre></td></tr></table></figure>
<h1 id="No-104-Maximun-Depth-of-Binary-Tree"><a href="#No-104-Maximun-Depth-of-Binary-Tree" class="headerlink" title="No.104 Maximun Depth of Binary Tree"></a>No.104 <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">Maximun Depth of Binary Tree</a></h1><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>Basic algorithm problem. Recursion is the simplist solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="No-226-Invert-Binary-Tree"><a href="#No-226-Invert-Binary-Tree" class="headerlink" title="No.226 Invert Binary Tree"></a>No.226 <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">Invert Binary Tree</a></h1><blockquote>
<p>Invert a binary tree.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>to<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Tuple equation is the simplist way to solve switch problems.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="No-237-Delete-Node-in-a-Linked-List"><a href="#No-237-Delete-Node-in-a-Linked-List" class="headerlink" title="No.237 Delete Node in a Linked List"></a>No.237 <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="external">Delete Node in a Linked List</a></h1><blockquote>
<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value 3, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.</p>
</blockquote>
<p>Unlike normal link node problems, the head node is unavailable. So we can not solve the front node’s next link. But this problem does not limit the node value such that we can replace the value of node by next node as a bypass solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure>
<h1 id="No-283-Move-Zeros"><a href="#No-283-Move-Zeros" class="headerlink" title="No.283 Move Zeros"></a>No.283 <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="external">Move Zeros</a></h1><blockquote>
<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
</blockquote>
<p>A simple solution is obvious and speed is not the best in this solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        n = nums.count(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">        nums.extend([<span class="number">0</span>]*n)</span><br></pre></td></tr></table></figure>
<p>The normal fast way is use two pointers. One points and one points last to find non-zero position to switch.</p>
<h1 id="No-100-Same-Tree"><a href="#No-100-Same-Tree" class="headerlink" title="No.100 Same Tree"></a>No.100 <a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">Same Tree</a></h1><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<p>A simple recursion problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> p != <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(q.right,p.right)</span><br></pre></td></tr></table></figure>
<h1 id="No-260-Single-Number-3"><a href="#No-260-Single-Number-3" class="headerlink" title="No.260 Single Number 3"></a>No.260 <a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="external">Single Number 3</a></h1><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given <code>nums = [1, 2, 1, 3, 2, 5]</code>, return <code>[3, 5]</code>.</p>
</blockquote>
<p>A common way is establish a dict to count so that the time complexity could be liinear runtime. But obviously the number set is big and the space sonsumption is not good. Anyway, it is fast solution~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        d = dict(zip(set(nums),[<span class="number">0</span>]*len(set(nums))))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> d:</span><br><span class="line">                d[i] += <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">if</span> d[i] == <span class="number">1</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-238-Product-of-Array-Except-Self"><a href="#No-238-Product-of-Array-Except-Self" class="headerlink" title="No.238 Product of Array Except Self"></a>No.238 <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h1><blockquote>
<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it <strong>without division</strong> and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
</blockquote>
<p>In this problem, we could only use multiply operation. A concise and common idea is establsh two support list. One of them save the left result of multiplying and another save the right. For example, the original list is <code>[1,2,3,4]</code> so the left multiplying result is [1,1,2,6] and the right is [24,12,4,1]. The time complexity is O(n) of these operation. Next procedure is obvious. Just do vector multiply and get the result.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        left = [<span class="number">1</span>]*length</span><br><span class="line">        right = [<span class="number">1</span>]*length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">            right[length-i<span class="number">-1</span>] = right[length-i]*nums[length-i]</span><br><span class="line">        result = [x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(left,right)]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-242-Valid-Anagram"><a href="#No-242-Valid-Anagram" class="headerlink" title="No.242 Valid Anagram"></a>No.242 <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="external">Valid Anagram</a></h1><blockquote>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
</blockquote>
<p>Using python power inside function is a concise solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        s1 = list(s)</span><br><span class="line">        s2 = list(t)</span><br><span class="line">        s1.sort()</span><br><span class="line">        s2.sort()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">''</span>.join(s1) == <span class="string">''</span>.join(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-171-Excel-Sheet-Column-Number"><a href="#No-171-Excel-Sheet-Column-Number" class="headerlink" title="No.171 Excel Sheet Column Number"></a>No.171 <a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="external">Excel Sheet Column Number</a></h1><blockquote>
<p>Related to question Excel Sheet Column Title</p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>The only important thing is the <code>ord</code> function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            sum = sum * <span class="number">26</span> + ord(i) - <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h1 id="No-217-Contains-Duplicate"><a href="#No-217-Contains-Duplicate" class="headerlink" title="No.217 Contains Duplicate"></a>No.217 <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="external">Contains Duplicate</a></h1><blockquote>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
</blockquote>
<p>Just use <code>set</code> and all things gone. Let us recite loudly – <strong>Python is almighty!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(set(nums)) &lt; len(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-169-Majority-Element"><a href="#No-169-Majority-Element" class="headerlink" title="No.169 Majority Element"></a>No.169 <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a></h1><blockquote>
<p>　Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<p>Because of the condition, a straight solution is sort the list and return the middle one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="No-268-Missing-Number"><a href="#No-268-Missing-Number" class="headerlink" title="No.268 Missing Number"></a>No.268 <a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="external">Missing Number</a></h1><blockquote>
<p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
</blockquote>
<p>No difficulty. Just be causious of boundary conditions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]+<span class="number">1</span> != nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">-1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="No-144-Binary-Tree-Preorder-Traversal"><a href="#No-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="No.144 Binary Tree Preorder Traversal"></a>No.144 <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">Binary Tree Preorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
</blockquote>
<p>Basic algorithm.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = [root.val]</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.preorderTraversal(root.left))</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>Iterable version is also easy. Stack construction can solve it perfectly.</p>
<h1 id="No-94-Binary-Tree-Inorder-Traversal"><a href="#No-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="No.94 Binary Tree Inorder Traversal"></a>No.94 <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">Binary Tree Inorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
</blockquote>
<p>Also a basic problem like the upper one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">            result = self.inorderTraversal(root.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = []</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.inorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>Iterable version is also simple structure of stack. Postorder one will be a little difficult which given below.</p>
<h1 id="No-145-Binary-Tree-Postorder-Traversal"><a href="#No-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="No.145 Binary Tree Postorder Traversal"></a>No.145 <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">Binary Tree Postorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
</blockquote>
<p>Now the last one of basic binary tree series. Unlike the former recursion solution, following is Iterable one.</p>
<p>In postorder, simple stack structure can not work, so we need to add a flag to represent whether the child nodes in stack. Suppose <code>False</code> flag means child node had enter in stack and <code>True</code> flag is opposite.</p>
<p>Obviously, if we have the flag, once we pop a node from stack, if flag is <code>True</code>, we can push it back and set False, and then push its left and right child node with True. Do it loop and problem solved.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        q = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q.append((root,<span class="keyword">True</span>))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x,y = q.pop()</span><br><span class="line">            l = x.left</span><br><span class="line">            r = x.right</span><br><span class="line">            <span class="keyword">if</span> y:</span><br><span class="line">                q.append((x,<span class="keyword">False</span>))</span><br><span class="line">                <span class="keyword">if</span> r:</span><br><span class="line">                    q.append((r,<span class="keyword">True</span>))</span><br><span class="line">                <span class="keyword">if</span> l:</span><br><span class="line">                    q.append((l,<span class="keyword">True</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(x.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-206-Reverse-Linked-List"><a href="#No-206-Reverse-Linked-List" class="headerlink" title="No.206 Reverse Linked List"></a>No.206 <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="external">Reverse Linked List</a></h1><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<p>Establish a new head pointer. We could cut the old chain one by one and stick to the front of new chain.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_head, p = head, head.next</span><br><span class="line">            new_head.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp, p = p, p.next</span><br><span class="line">            new_head, tmp.next = tmp, new_head</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<h1 id="No-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#No-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="No.235 Lowest Common Ancestor of a Binary Search Tree"></a>No.235 <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="external">Lowest Common Ancestor of a Binary Search Tree</a></h1><blockquote>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              <span class="string">\</span></span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      <span class="string">\</span>        /      <span class="string">\</span></span><br><span class="line"><span class="number">0</span>      _4       <span class="number">7</span>       <span class="number">9</span></span><br><span class="line">      /  <span class="string">\</span></span><br><span class="line">      <span class="number">3</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>Like decision tree. First, if one of them is root, done. Else, if root value between them, they must divided in different chile tree, so the root is the lowest common ancestor. In other word, if the root is not the middle one, they must in the same child tree, so we can use recursion to solve.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> p <span class="keyword">or</span> root <span class="keyword">is</span> q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val &lt; q.val <span class="keyword">or</span> q.val &lt; root.val &lt; p.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure>
<h1 id="No-191-Number-of-1-Bits"><a href="#No-191-Number-of-1-Bits" class="headerlink" title="No.191 Number of 1 Bits"></a>No.191 <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="external">Number of 1 Bits</a></h1><blockquote>
<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return <code>3</code>.</p>
</blockquote>
<p>Bsic problem. We can use <code>&gt;&gt;</code> operation. <code>bin</code>　it and change to char list to solve is also good way.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            tail = n % <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> tail == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h1 id="No-328-Odd-Even-Linked-List"><a href="#No-328-Odd-Even-Linked-List" class="headerlink" title="No.328 Odd Even Linked List"></a>No.328 <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="external">Odd Even Linked List</a></h1><blockquote>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>return <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
</blockquote>
<p>Inplace produce more difficuty, but the algorithm is not complex.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            odd = head</span><br><span class="line">            even_head = even = head.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> even:</span><br><span class="line">                odd.next = even.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> odd.next:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                odd = odd.next</span><br><span class="line">                even.next = odd.next</span><br><span class="line">                even = even.next</span><br><span class="line"></span><br><span class="line">            odd.next = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-137-Single-Number-2"><a href="#No-137-Single-Number-2" class="headerlink" title="No.137 Single Number 2"></a>No.137 <a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="external">Single Number 2</a></h1><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>Also use <code>set</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> (sum(set(nums))*<span class="number">3</span> - sum(nums))/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="No-96-Unique-Binary-Search-Trees"><a href="#No-96-Unique-Binary-Search-Trees" class="headerlink" title="No.96 Unique Binary Search Trees"></a>No.96 <a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="external">Unique Binary Search Trees</a></h1><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
</blockquote>
<p>Recursion is a typical solution. But it actually a mathematical problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> math.factorial(<span class="number">2</span>*n)/(math.factorial(n)*math.factorial(n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h1 id="No-141-Linked-List-Cycle"><a href="#No-141-Linked-List-Cycle" class="headerlink" title="No.141 Linked List Cycle"></a>No.141 <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h1><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>A very interesting problem. The solution is even more amazing. We establsh two pointers, a pointer move one pace each time and another is two. If there is a cycle, they must meet again.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            head1 = head</span><br><span class="line">            head2 = head.next</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> head1 <span class="keyword">is</span> head2:</span><br><span class="line">                head1 = head1.next</span><br><span class="line">                head2 = head2.next.next</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-35-Search-Insert-Position"><a href="#No-35-Search-Insert-Position" class="headerlink" title="No.35 Search Insert Position"></a>No.35 <a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">Search Insert Position</a></h1><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<p>An easy problem, <code>enumerate</code> is useful.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#No-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="No.108 Convert Sorted Array to Binary Search Tree"></a>No.108 <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted Array to Binary Search Tree</a></h1><blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<p>recursion is perfect.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        m = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">        root = TreeNode(nums[m])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:m])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[m+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="No-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#No-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="No.116 Populating Next Right Pointers in Each Node"></a>No.116 <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h1><blockquote>
<p>Given a binary tree<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> TreeLinkNode &#123;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *left;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *right;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
</blockquote>
<p>For this situation, we could use BFS algorithm which also named scan strategy.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array = []</span><br><span class="line">            new_array = []</span><br><span class="line">            array.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">if</span> array[<span class="number">0</span>].left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">                    new_array.append(item.left)</span><br><span class="line">                    new_array.append(item.right)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new_array)<span class="number">-1</span>):</span><br><span class="line">                    new_array[i].next = new_array[i+<span class="number">1</span>]</span><br><span class="line">                array = new_array</span><br><span class="line">                new_array = []</span><br></pre></td></tr></table></figure>
<h1 id="No-230-Kth-Smallest-Element-in-a-BST"><a href="#No-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="No.230 Kth Smallest Element in a BST"></a>No.230 <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="external">Kth Smallest Element in a BST</a></h1><blockquote>
<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
</blockquote>
<p>We could use inorder search to get the kth number. The follwing is a Iterable solution using stack. Recursion is also a typical way.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        l = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            l.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            pop_num = l.pop()</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> pop_num.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                tmp = pop_num.right</span><br><span class="line">                <span class="keyword">while</span> tmp:</span><br><span class="line">                    l.append(tmp)</span><br><span class="line">                    tmp = tmp.left</span><br></pre></td></tr></table></figure>
<p>For answer the follw up problem, we should modify the raw structure of BST. We could modify the original one to inorder clue tree to get the next node easily and do not waste space. A inorde head need a extra room.</p>
<h1 id="No-83-Remove-Duplicates-from-Sorted-List"><a href="#No-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="No.83 Remove Duplicates from Sorted List"></a>No.83 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h1><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
</blockquote>
<p>A easy problem. Just take care the bounary condition.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cursor = head</span><br><span class="line">            <span class="keyword">while</span> cursor.next:</span><br><span class="line">                <span class="keyword">if</span> cursor.val == cursor.next.val:</span><br><span class="line">                    cursor.next = cursor.next.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-70-Climbing-Stairs"><a href="#No-70-Climbing-Stairs" class="headerlink" title="No.70 Climbing Stairs"></a>No.70 <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="external">Climbing Stairs</a></h1><blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p>Recursion is the first idea in my brain. It is avalaible theoretically, but the reply is error message of recurion depth limit. So, we must using iterable way.</p>
<p>The solution is like Fibonacci array.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        first = <span class="number">1</span></span><br><span class="line">        second = <span class="number">2</span></span><br><span class="line">        start = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">                first, second = second, first+second</span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure>
<h1 id="No-53-Maximum-Subarray"><a href="#No-53-Maximum-Subarray" class="headerlink" title="No.53 Maximum Subarray"></a>No.53 <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">Maximum Subarray</a></h1><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[−2,1,−3,4,−1,2,1,−5,4]</code>,<br>the contiguous subarray <code>[4,−1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<p>A typical DP(dynamic programming) problem. Just Google it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_num = max(nums)</span><br><span class="line">        <span class="keyword">if</span> max_num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max_num</span><br><span class="line">        max_of_all = max_of_tail = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            max_of_tail = max(nums[i],nums[i]+max_of_tail)</span><br><span class="line">            max_of_all = max(max_of_all, max_of_tail)</span><br><span class="line">        <span class="keyword">return</span> max_of_all</span><br></pre></td></tr></table></figure>
<h1 id="No-263-Ugly-Number"><a href="#No-263-Ugly-Number" class="headerlink" title="No.263 Ugly Number"></a>No.263 <a href="https://leetcode.com/problems/ugly-number/" target="_blank" rel="external">Ugly Number</a></h1><blockquote>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
</blockquote>
<p>A easy problem and also be cautious of Boundary condition.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> num <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-202-Happy-Number"><a href="#No-202-Happy-Number" class="headerlink" title="No.202 Happy Number"></a>No.202 <a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="external">Happy Number</a></h1><blockquote>
<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
</blockquote>
<p>Python inside functions <code>list</code> and <code>str</code> can easily solve the problem while they are conbined.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            nums.append(n)</span><br><span class="line">            l = list(str(n))</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                n += (ord(i)<span class="number">-48</span>)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-326-Power-of-Three"><a href="#No-326-Power-of-Three" class="headerlink" title="No.326 Power of Three"></a>No.326 <a href="https://leetcode.com/problems/power-of-three/" target="_blank" rel="external">Power of Three</a></h1><blockquote>
<p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
</blockquote>
<p>If you use loop, everything goes well.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            i *= <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>There is a very tricky way to solve the problem without loop or recursion. We must face the fact that the problem is in computer rather than in math. The biggest number which is the power of 3 is specific. so if <code>biggest_3_power % target == 0</code>, then the target number is the ture answer.</p>
<p>No matter what is your thought, mine is WTF.</p>
<h1 id="No-89-Gray-Code"><a href="#No-89-Gray-Code" class="headerlink" title="No.89 Gray Code"></a>No.89 <a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="external">Gray Code</a></h1><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00 </span>- <span class="number">0</span></span><br><span class="line"><span class="symbol">01 </span>- <span class="number">1</span></span><br><span class="line"><span class="symbol">11 </span>- <span class="number">3</span></span><br><span class="line"><span class="symbol">10 </span>- <span class="number">2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>The key idea of this Algorithm is reduce. Once k size problem solved, we could add bit code 1 at the front of every number in the list and get a new array. Then reverse it and stick together. The new array fit Gray rule and it is the k+1 size answer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        r = self.grayCode(n<span class="number">-1</span>)</span><br><span class="line">        result = [x + (<span class="number">1</span> &lt;&lt; (n<span class="number">-1</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> r]</span><br><span class="line">        result.reverse()</span><br><span class="line">        r.extend(result)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h1 id="No-62-Unique-Paths"><a href="#No-62-Unique-Paths" class="headerlink" title="No.62 Unique Paths"></a>No.62 <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="external">Unique Paths</a></h1><blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<p>Actually a math problem. A transfomation of pascal triangle. Math solution is perfect.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> math.factorial(m+n<span class="number">-2</span>)/(math.factorial(m<span class="number">-1</span>)*math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<h1 id="No-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#No-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="No.153 Find Minimum in Rotated Sorted Array"></a>No.153 <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a></h1><blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>A search problem. Dichoctomizing search is the key.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l+r)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m]&gt;nums[m+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[m+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[l]:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="No-21-Merge-Two-Sorted-Lists"><a href="#No-21-Merge-Two-Sorted-Lists" class="headerlink" title="No.21 Merge Two Sorted Lists"></a>No.21 <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h1><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>A NodeList typical problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                p.next = l2</span><br><span class="line">                p = p.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = l1</span><br><span class="line">                p = p.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.next = l1</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<h1 id="No-46-Permutations"><a href="#No-46-Permutations" class="headerlink" title="No.46 Permutations"></a>No.46 <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">Permutations</a></h1><blockquote>
<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br><code>[1,2,3]</code> have the following permutations:<br><code>[1,2,3]</code>, <code>[1,3,2]</code>, <code>[2,1,3]</code>, <code>[2,3,1]</code>, <code>[3,1,2]</code>, and <code>[3,2,1]</code>.</p>
</blockquote>
<p>Another recursion.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">            """</span></span><br><span class="line">        <span class="keyword">return</span> self.sub(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> [[]]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> [nums]</span><br><span class="line">        pattern = self.sub(nums[<span class="number">1</span>:])</span><br><span class="line">        c = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> pattern:</span><br><span class="line">                c.append(p[:i] + [nums[<span class="number">0</span>]] + p[i:])</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
<h1 id="No-24-Swap-Nodes-in-Pairs"><a href="#No-24-Swap-Nodes-in-Pairs" class="headerlink" title="No.24 Swap Nodes in Pairs"></a>No.24 <a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="external">Swap Nodes in Pairs</a></h1><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<p>Take care of Boundary condition and other is only NodeList.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        first,second = head, head.next</span><br><span class="line">        third = second.next</span><br><span class="line">        head = second</span><br><span class="line">        second.next = first</span><br><span class="line">        first.next = self.swapPairs(third)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-216-Combination-Sum-3"><a href="#No-216-Combination-Sum-3" class="headerlink" title="No.216 Combination Sum 3"></a>No.216 <a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="external">Combination Sum 3</a></h1><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
</blockquote>
<p>DFS problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(k,n,index,path,result)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> <span class="keyword">not</span> k:result.append(path)</span><br><span class="line">            <span class="keyword">if</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(index,<span class="number">10</span>):</span><br><span class="line">                    dfs(k<span class="number">-1</span>,n-i,i+<span class="number">1</span>,path+[i],result)</span><br><span class="line">        result=[]</span><br><span class="line">        dfs(k,n,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://migdal-bavel.in.com/2016/02/29/leetcode记/" data-id="cir3a923i0008fjs6fj7giz04" class="article-share-link">分享到</a><div class="tags"><a href="/tags/算法/">算法</a><a href="/tags/python/">python</a></div><div class="post-nav"><a href="/2016/06/04/线性回归和梯度下降/" class="pre">线性回归和梯度下降</a><a href="/2016/02/14/数独的高效深度搜索解法/" class="next">数独的高效深度搜索解法</a></div><div data-thread-key="2016/02/29/leetcode记/" data-title="leetcode记（持续更新中）" data-url="http://migdal-bavel.in.com/2016/02/29/leetcode记/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/02/29/leetcode记/" data-title="leetcode记（持续更新中）" data-url="http://migdal-bavel.in.com/2016/02/29/leetcode记/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/教程/" style="font-size: 15px;">教程</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/博弈/" style="font-size: 15px;">博弈</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/math/" style="font-size: 15px;">math</a> <a href="/tags/machine-learning/" style="font-size: 15px;">machine learning</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/scrapy/" style="font-size: 15px;">scrapy</a> <a href="/tags/ai/" style="font-size: 15px;">ai</a> <a href="/tags/数据/" style="font-size: 15px;">数据</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/HEXO/" style="font-size: 15px;">HEXO</a> <a href="/tags/建博客/" style="font-size: 15px;">建博客</a> <a href="/tags/Github-Pages/" style="font-size: 15px;">Github Pages</a> <a href="/tags/数独/" style="font-size: 15px;">数独</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/游戏/" style="font-size: 15px;">游戏</a> <a href="/tags/数据挖掘/" style="font-size: 15px;">数据挖掘</a> <a href="/tags/聚类/" style="font-size: 15px;">聚类</a> <a href="/tags/machine-learing/" style="font-size: 15px;">machine learing</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/26/2048-ai小试/">2048 ai小试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/logistic分类器/">logistic分类器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/04/线性回归和梯度下降/">线性回归和梯度下降</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/leetcode记/">leetcode记（持续更新中）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/14/数独的高效深度搜索解法/">数独的高效深度搜索解法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/30/python和数据库的接口简介/">python和数据库的接口简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/暴力解决三门问题/">暴力解决三门问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/26/让我们来研究一下神奇的连连看/">让我们来研究一下神奇的连连看</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/20/用python实现kmeans算法/">用python实现kmeans算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/22/一定要养成备份文件的好习惯，防止手贱/">一定要养成备份文件的好习惯，防止手贱</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://mathpluscode.com/" title="Pierre Fu 法国逍遥少年" target="_blank">Pierre Fu 法国逍遥少年</a><ul></ul><a href="http://v1ns0n.github.io/" title="v1ns0n 上交苦逼博士" target="_blank">v1ns0n 上交苦逼博士</a><ul></ul><a href="http://xiaoyc.com/" title="xiaoyc 肖大神" target="_blank">xiaoyc 肖大神</a><ul></ul><a href="http://handsomeone.com/" title="周男神" target="_blank">周男神</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">巴别塔.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'migdal-bavel'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d0f9ddc5837fa2c13aa39295424a1eec";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>