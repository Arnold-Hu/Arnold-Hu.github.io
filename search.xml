<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[logistic分类器]]></title>
      <url>http://migdal-bavel.in.com/2016/06/17/logistic%E5%88%86%E7%B1%BB%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>现在我们来到了分类器，首先我们考虑一个最简单的二元分类器，抽象成只判断对错。那么，换句话说我们希望我们得到的结果是离散的，但是我们前面的函数都是线性的，显然不能很好的处理这一类问题，所以，我们得新引进一个函数来把连续的结果处理成离散的效果，轮到logistic函数（又称sigmoid函数）登场了</p>
<p>$$g(x)=\frac{1}{1+e^{-x}}$$</p>
<p>图像如下，很明显可以看出越靠近零点斜率变化越大，函数在0点附近急剧的变化到0和1，这正是两个非常适于数学处理的离散值。<br><img src="http://7xl294.com1.z0.glb.clouddn.com/sigmoid.png" alt=""></p>
<p>而基于线性回归，我们可以用一条线（或者说是超平面）来分割点集来得到分类的效果，那么我们可以通过刚才介绍的logistic函数来的到离散化的反馈结果来进行优化。那么我们的预测函数$h_\theta (x)$如下</p>
<p>$$h_\theta (x)=g(\theta^T x) = \frac{1}{1+e^{-\theta^T x}}$$</p>
<p>那我们怎么来对$\theta$进行迭代优化呢？线性回归可以通过极大似然估计，这个自然也是ok的，那么，我们也来估计一下。</p>
<h3 id="概率意义"><a href="#概率意义" class="headerlink" title="概率意义"></a>概率意义</h3><p>根据$h_\theta (x)$的意义，我们能够得到下面的等式<br>$$P(y=1|x;\theta)=h_\theta(x)$$<br>$$P(y=0|x;\theta)=1-h_\theta(x)$$<br>那么，综合一下得到一个适合数学分析的等式<br>$$P(y|x;\theta) = h_\theta(x)^y (1-h(x))^{1-y}$$</p>
<p>同样，我们求极大似然估计<br>$$L(\theta) = \prod_{i=1}^m h_\theta (x^{(i)})^{y^{(i)}} (1-h(x^{(i)}))^{1-y^{(i)}}$$<br>$$l(\theta) = log(L(\theta)) = \sum_{i=1}^m y^{(i)}log(h_\theta(x^{(i)})) + (1-y^{(i)})log(1-h_\theta(x^{(i)}))$$</p>
<p>我们要使$l(\theta)$最大，那么自然而然我们可以用到梯度上升法，那么，每次的迭代就是这样</p>
<p>$$\theta := \theta + \alpha \nabla_\theta l(\theta)$$</p>
<p>现在的问题就是怎么求$l(\theta)$关于$\theta$的梯度</p>
<p>首先，我们先求<br>$$\begin{align}<br>\frac{\partial h_\theta (x^{(i)})}{\partial \theta_j} &amp;=<br>-(\frac{1}{1+e^{-\theta^T x^{(i)}}})^2 \bullet e^{-\theta^T x^{(i)}} \bullet (-x_j^{(i)}) \\<br>&amp;= \frac{1}{1+e^{-\theta^T x^{(i)}}} \bullet \frac{e^{-\theta^T x^{(i)}}}{1+e^{-\theta^T x^{(i)}}} \bullet x_j^{(i)} \\<br>&amp;= h_\theta (x^{(i)})(1-h_\theta (x^{(i)})) x_j^{(i)}<br>\end{align}$$</p>
<p>那么，我们带入可以求得<br>$$\begin{align}<br>&amp; \frac{\partial}{\partial \theta_j} \sum_{i=1}^m y^{(i)}logh_\theta(x^{(i)}) + (1-y^{(i)})log(1- h_\theta(x^{(i)})) \\<br>&amp;= \sum_{i=1}^m \frac{1}{h_\theta (x^{(i)})} \bullet \frac{\partial h_\theta (x^{(i)})}{\partial \theta_j} +<br>(1-y^{(i)}) \bullet \frac{1}{1-h_\theta (x^{(i)})} \bullet \frac{\partial (1-h_\theta (x^{(i)}))}{\partial \theta_j} \\<br>&amp;= \sum_{i=1}^m y^{(i)}(1-h_\theta(x^{(i)}))x_j^{(i)} - (1-y^{(i)})h_\theta(x^{(i)})x_j^{(i)} \\<br>&amp;= \sum_{i=1}^m (y^{(i)} - h_\theta(x^{(i)}))x_j^{(i)}<br>\end{align}$$</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>最终我们得到了$\theta$的迭代式<br>$$\theta_j := \theta_j + \alpha \sum_{i=1}^m \left[ y^{(i)}-h_\theta (x^{(i)}) \right] x_j^{(i)}$$</p>
<p>自然，我们也可以和线性回归的方法一样用随机梯度法</p>
<p>$$ \theta_j := \theta_j + \alpha \left[ y^{(i)}-h_\theta (x^{(i)}) \right] x_j^{(i)}$$</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线性回归和梯度下降]]></title>
      <url>http://migdal-bavel.in.com/2016/06/04/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      <content type="html"><![CDATA[<p>找了工作之后好像好久没有更新了,很多东西都忘记了,刚好最近正在重新入门machine learning,就写一下最简单的线性回归,重新捡一下快忘记的numpy, matplotlib,和latex.</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>现在假设我们有$m$个数据$x$,并且每个数据都有$n$个特征,相应的这些数据所对应的结果为$y$,也是$m$个.我们希望能找到一组线性参数来对任意一个样本尽量准的预测其结果.这样的参数向量我们称为$\theta$,而我们希望用这样一个函数来预测$y$<br>$$y = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \ldots + \theta_n x_n$$<br>或者用简洁的矩阵表示<br>$$y = \theta^Tx$$<br>而梯度下降法则是提供了一个有效的学习方法,从每次训练得到的反馈中修正参数直到收敛.</p>
<p>那根据上面的定义,我们就能很明确在这个过程中有两件事很关键.</p>
<p><strong>一是如何度量预测的准不准</strong></p>
<p><strong>二是如何根据每次的反馈修正参数</strong></p>
<h3 id="度量预测"><a href="#度量预测" class="headerlink" title="度量预测"></a>度量预测</h3><p>通过$\theta$和$x$,我们可以预测出对应的$y$,然而这个预测出的$y$和真实的$y$肯定是有误差的,那么自然而然,我们在借用统计里的方法,可以定义这个准确程度为<br>$$J(\theta)=\sum_{i=1}^m \left( h_{\theta}(x^{i}) - y^{(i)} \right)^2$$<br>现在我们有了一个可以度量误差的方法,那么,我们的目标也就显而易见了,就是使这个误差函数最小.而如何使其最小则是梯度下降法的工作了.</p>
<p>当我们得到一个函数,我们怎么能够知道往哪个方向走下一步能够最快的接近最小值呢？对高等数学熟悉的话一下子就能想到梯度的概念—在函数上的任意一点,其导数的方向就是函数值变化最大的方向.那么我们可以通过求导来获得下一步的方向.<br>$$\begin{align}<br>\frac{\partial J(\theta)}{\partial \theta_j} &amp;=  \frac{\partial}{\partial \theta_j} \sum_{i=1}^m \left (h_{\theta}(x^{i}) - y^{(i)} \right )^2 \\<br>&amp;=  2\sum_{i=1}^m \left ( (h_{\theta}(x^{i}) - y^{(i)}) \, \frac{\partial}{\partial \theta_j}(h_{\theta}(x^{i}) - y^{(i)}) \right ) \\<br>&amp;= 2\sum_{i=1}^m \left( h_{\theta}(x^{i}) - y^{(i)}\right) x^{(i)}_j<br>\end{align}<br>$$<br>在很多参考书中,为了整洁美观,都会使$J(\theta)$前多加一个参数$\frac{1}{2}$,使得导数变成$\sum_{i=1}^m \left( h_{\theta}(x^{i}) - y^{(i)}\right) x_i$,我们随大流,也用这样的方法定义,不过其实都没有差啦.</p>
<p>由此我们得到每一次的迭代方法<br>$$\theta_i := \theta_i - \alpha\sum_{i=1}^m \left( h_{\theta}(x^{i}) - y^{(i)}\right) x^{(i)}_j \tag{ for i=1,2, … ,n }$$</p>
<p>这里的$\alpha$是每次梯度下降的步长,步长如果选短了会下降的很慢,迭代很多次,二步长选长了则会出现在最优点附近徘徊甚至直接远离最优点.选好$\alpha$真是一门学问.</p>
<p>通过这种方法迭代的梯度下降法称为批量梯度爱心将法,因为每一次迭代都需要所有的训练点参与计算.二还有另外一种增量梯度下降算法或者说最忌梯度下降算法则每一次只使用一个点来训练,他的迭代公式是<br>$$\theta := \theta - \alpha \left( \theta^T x^{(i)} - y^{(i)} \right)x^{(i)}_j$$</p>
<h3 id="我有图片"><a href="#我有图片" class="headerlink" title="我有图片"></a>我有图片</h3><p>好的,下面我们就要上图了.</p>
<p>下面三个图都是迭代次数为10的情况，左上角是批量梯度下降，右上角是随机梯度下降，下方是在等高线上参数的步进情况。</p>
<p>$$ \alpha = 0.5$$<br><img src="http://7xl294.com1.z0.glb.clouddn.com/a_05-iter_10.png" alt=""><br>$$ \alpha = 1$$<br><img src="http://7xl294.com1.z0.glb.clouddn.com/a_1-iter_10.png" alt=""><br>$$ \alpha = 1.5$$<br><img src="http://7xl294.com1.z0.glb.clouddn.com/a_15-iter_10.png" alt=""></p>
<h3 id="最小二乘法的概率解释"><a href="#最小二乘法的概率解释" class="headerlink" title="最小二乘法的概率解释"></a>最小二乘法的概率解释</h3><p>我们在前面只用了一些特征来对这个模型进行剑魔，而在现实中相对所有的影响因素剑魔是不太可能的，所以在预测过程中肯定会有很多未捕捉或者说未参与建模的特征没有在函数中体现，我们可以利用一个误差项  $\epsilon$  来统一的表示这个误差。<br>    那么我们的预测模型就可以这样写<br>$$ y^{(i)} = h_{\theta}(x^{(i)}) + \epsilon^{(i)} $$<br>而现在我们就为了解释这个模型提出一个假设，我们假设误差满足高斯分布<br>$$    \epsilon \sim \mathscr{N}(0, \sigma^2)$$<br>即<br>$$ P(\epsilon^{(i)}) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(\epsilon^{(i)})^2}{2\sigma^2}) $$</p>
<p>为什么我们能够先验的认为这个误差的分布满足正态分布呢？首先，也是最重要的，时间表明这个方法对于大多数情况都描述的很好，更理论一些的要涉及到概率论的中心极限定理，如果有概率论基础的自然明白，没有的话可以直接视为正态分布是对随机误差的非常优秀的刻画。</p>
<p>根据$\epsilon$的概率分布，我们可以得到$x$,$y$的概率分布。<br>$$ P(y^{(i)}|x^{(i)};\theta) =\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)} - h_\theta(x^{(i)}))^2}{2\sigma^2}) $$<br>即<br>$$ y^{(i)}  \sim  \mathscr{N}( h_\theta (x^{(i)}), \sigma^2)$$</p>
<p>如此，我们就可以对$\theta$进行参数估计，当当当，极大似然估计登场。我们用极大似然估计的方法给出$\theta$的估计值，即我们队$\theta$的估计值就是使下式值最大的$\theta$<br>$$ L(\theta) = \prod_{i=1}^n \frac{1}{\sqrt{2\pi}\sigma}exp\left(-\frac{(y^{(i)} - h_\theta(x^{(i)}))^2}{2\sigma^2}\right)$$<br>不改变单调性，我们通常取对数来处理<br>$$\begin{align}<br>l(\theta) = ln\left(L(\theta)\right) &amp;= \sum_{i=1}^n ln\left(\frac{1}{\sqrt{2\pi}\sigma}\right)-\frac{(y^{(i)} - h_\theta(x^{(i)}))^2}{2\sigma^2} \\<br>&amp;= mln\left(\frac{1}{\sqrt{2\pi}\sigma}\right) + \frac{1}{2\sigma^2}\sum_{i=1}^n -\left( y^{(i)}-h_\theta(x^{(i)}) \right)^2<br>\end{align}$$</p>
<p>因为$\sigma$是常数，那么我们只需求使<br>$$ \sum_{i=1}^n \left( y^{(i)}-h_\theta(x^{(i)}) \right)^2 $$<br>最小就达到了最大似然估计的要求。</p>
<p>是不是很眼熟，这个就是我们一开始定义的对误差的度量。</p>
<p>至此，我们就得到在先前得到的描述误差的函数，表示这个误差描述函数不是凭空掉下的林妹妹~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[leetcode记（持续更新中）]]></title>
      <url>http://migdal-bavel.in.com/2016/02/29/leetcode%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>This is a personal answers of leetcode problem. My aim is to find the fast way to solve the problems by python. In some cases, the time or space complexity may be sacrificed. All the problems sorted by AC rate.</p>
<h1 id="No-292-Nim-game"><a href="#No-292-Nim-game" class="headerlink" title="No.292 Nim game"></a>No.292 <a href="https://leetcode.com/problems/nim-game/" target="_blank" rel="external">Nim game</a></h1><blockquote>
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.<br>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.<br>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
</blockquote>
<p>The introduction leaks the most important hint that if there are 4 stones left and you are the first, you will never win. So, our aim is to let the opponent to face this situation. Obviously, if you are the first and can not make the number of left stones as 4n, you must lose. This is a math problem and code is nonsence.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h1 id="No-136-Single-Number"><a href="#No-136-Single-Number" class="headerlink" title="No.136 Single Number"></a>No.136 <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">Single Number</a></h1><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
</blockquote>
<p>Very common problem, set function is a very simple solution of these kind of problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(set(nums))*<span class="number">2</span>-sum(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-258-Add-Digits"><a href="#No-258-Add-Digits" class="headerlink" title="No.258 Add Digits"></a>No.258 <a href="https://leetcode.com/problems/add-digits/" target="_blank" rel="external">Add Digits</a></h1><blockquote>
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
</blockquote>
<p>Python flexible str and list function will solve the problem　concisely.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(list(str(num))) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(map(int,list(str(num))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.addDigits(sum(map(int,list(str(num)))))</span><br></pre></td></tr></table></figure>
<h1 id="No-104-Maximun-Depth-of-Binary-Tree"><a href="#No-104-Maximun-Depth-of-Binary-Tree" class="headerlink" title="No.104 Maximun Depth of Binary Tree"></a>No.104 <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">Maximun Depth of Binary Tree</a></h1><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>Basic algorithm problem. Recursion is the simplist solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="No-226-Invert-Binary-Tree"><a href="#No-226-Invert-Binary-Tree" class="headerlink" title="No.226 Invert Binary Tree"></a>No.226 <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">Invert Binary Tree</a></h1><blockquote>
<p>Invert a binary tree.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>to<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Tuple equation is the simplist way to solve switch problems.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="No-237-Delete-Node-in-a-Linked-List"><a href="#No-237-Delete-Node-in-a-Linked-List" class="headerlink" title="No.237 Delete Node in a Linked List"></a>No.237 <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="external">Delete Node in a Linked List</a></h1><blockquote>
<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value 3, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.</p>
</blockquote>
<p>Unlike normal link node problems, the head node is unavailable. So we can not solve the front node’s next link. But this problem does not limit the node value such that we can replace the value of node by next node as a bypass solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure>
<h1 id="No-283-Move-Zeros"><a href="#No-283-Move-Zeros" class="headerlink" title="No.283 Move Zeros"></a>No.283 <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="external">Move Zeros</a></h1><blockquote>
<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
</blockquote>
<p>A simple solution is obvious and speed is not the best in this solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        n = nums.count(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">        nums.extend([<span class="number">0</span>]*n)</span><br></pre></td></tr></table></figure>
<p>The normal fast way is use two pointers. One points and one points last to find non-zero position to switch.</p>
<h1 id="No-100-Same-Tree"><a href="#No-100-Same-Tree" class="headerlink" title="No.100 Same Tree"></a>No.100 <a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="external">Same Tree</a></h1><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<p>A simple recursion problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> p != <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(q.right,p.right)</span><br></pre></td></tr></table></figure>
<h1 id="No-260-Single-Number-3"><a href="#No-260-Single-Number-3" class="headerlink" title="No.260 Single Number 3"></a>No.260 <a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="external">Single Number 3</a></h1><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given <code>nums = [1, 2, 1, 3, 2, 5]</code>, return <code>[3, 5]</code>.</p>
</blockquote>
<p>A common way is establish a dict to count so that the time complexity could be liinear runtime. But obviously the number set is big and the space sonsumption is not good. Anyway, it is fast solution~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        d = dict(zip(set(nums),[<span class="number">0</span>]*len(set(nums))))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> d:</span><br><span class="line">                d[i] += <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">if</span> d[i] == <span class="number">1</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-238-Product-of-Array-Except-Self"><a href="#No-238-Product-of-Array-Except-Self" class="headerlink" title="No.238 Product of Array Except Self"></a>No.238 <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="external">Product of Array Except Self</a></h1><blockquote>
<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it <strong>without division</strong> and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
</blockquote>
<p>In this problem, we could only use multiply operation. A concise and common idea is establsh two support list. One of them save the left result of multiplying and another save the right. For example, the original list is <code>[1,2,3,4]</code> so the left multiplying result is [1,1,2,6] and the right is [24,12,4,1]. The time complexity is O(n) of these operation. Next procedure is obvious. Just do vector multiply and get the result.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        left = [<span class="number">1</span>]*length</span><br><span class="line">        right = [<span class="number">1</span>]*length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">            right[length-i<span class="number">-1</span>] = right[length-i]*nums[length-i]</span><br><span class="line">        result = [x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(left,right)]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-242-Valid-Anagram"><a href="#No-242-Valid-Anagram" class="headerlink" title="No.242 Valid Anagram"></a>No.242 <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="external">Valid Anagram</a></h1><blockquote>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
</blockquote>
<p>Using python power inside function is a concise solution.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        s1 = list(s)</span><br><span class="line">        s2 = list(t)</span><br><span class="line">        s1.sort()</span><br><span class="line">        s2.sort()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">''</span>.join(s1) == <span class="string">''</span>.join(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-171-Excel-Sheet-Column-Number"><a href="#No-171-Excel-Sheet-Column-Number" class="headerlink" title="No.171 Excel Sheet Column Number"></a>No.171 <a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="external">Excel Sheet Column Number</a></h1><blockquote>
<p>Related to question Excel Sheet Column Title</p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>The only important thing is the <code>ord</code> function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            sum = sum * <span class="number">26</span> + ord(i) - <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h1 id="No-217-Contains-Duplicate"><a href="#No-217-Contains-Duplicate" class="headerlink" title="No.217 Contains Duplicate"></a>No.217 <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="external">Contains Duplicate</a></h1><blockquote>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
</blockquote>
<p>Just use <code>set</code> and all things gone. Let us recite loudly – <strong>Python is almighty!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(set(nums)) &lt; len(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-169-Majority-Element"><a href="#No-169-Majority-Element" class="headerlink" title="No.169 Majority Element"></a>No.169 <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a></h1><blockquote>
<p>　Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<p>Because of the condition, a straight solution is sort the list and return the middle one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="No-268-Missing-Number"><a href="#No-268-Missing-Number" class="headerlink" title="No.268 Missing Number"></a>No.268 <a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="external">Missing Number</a></h1><blockquote>
<p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
</blockquote>
<p>No difficulty. Just be causious of boundary conditions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]+<span class="number">1</span> != nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">-1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="No-144-Binary-Tree-Preorder-Traversal"><a href="#No-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="No.144 Binary Tree Preorder Traversal"></a>No.144 <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="external">Binary Tree Preorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
</blockquote>
<p>Basic algorithm.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = [root.val]</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.preorderTraversal(root.left))</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>Iterable version is also easy. Stack construction can solve it perfectly.</p>
<h1 id="No-94-Binary-Tree-Inorder-Traversal"><a href="#No-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="No.94 Binary Tree Inorder Traversal"></a>No.94 <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="external">Binary Tree Inorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
</blockquote>
<p>Also a basic problem like the upper one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">            result = self.inorderTraversal(root.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = []</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            result.extend(self.inorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>Iterable version is also simple structure of stack. Postorder one will be a little difficult which given below.</p>
<h1 id="No-145-Binary-Tree-Postorder-Traversal"><a href="#No-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="No.145 Binary Tree Postorder Traversal"></a>No.145 <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="external">Binary Tree Postorder Traversal</a></h1><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
</blockquote>
<p>Now the last one of basic binary tree series. Unlike the former recursion solution, following is Iterable one.</p>
<p>In postorder, simple stack structure can not work, so we need to add a flag to represent whether the child nodes in stack. Suppose <code>False</code> flag means child node had enter in stack and <code>True</code> flag is opposite.</p>
<p>Obviously, if we have the flag, once we pop a node from stack, if flag is <code>True</code>, we can push it back and set False, and then push its left and right child node with True. Do it loop and problem solved.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        q = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q.append((root,<span class="keyword">True</span>))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x,y = q.pop()</span><br><span class="line">            l = x.left</span><br><span class="line">            r = x.right</span><br><span class="line">            <span class="keyword">if</span> y:</span><br><span class="line">                q.append((x,<span class="keyword">False</span>))</span><br><span class="line">                <span class="keyword">if</span> r:</span><br><span class="line">                    q.append((r,<span class="keyword">True</span>))</span><br><span class="line">                <span class="keyword">if</span> l:</span><br><span class="line">                    q.append((l,<span class="keyword">True</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(x.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="No-206-Reverse-Linked-List"><a href="#No-206-Reverse-Linked-List" class="headerlink" title="No.206 Reverse Linked List"></a>No.206 <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="external">Reverse Linked List</a></h1><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<p>Establish a new head pointer. We could cut the old chain one by one and stick to the front of new chain.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_head, p = head, head.next</span><br><span class="line">            new_head.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp, p = p, p.next</span><br><span class="line">            new_head, tmp.next = tmp, new_head</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<h1 id="No-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#No-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="No.235 Lowest Common Ancestor of a Binary Search Tree"></a>No.235 <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="external">Lowest Common Ancestor of a Binary Search Tree</a></h1><blockquote>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              <span class="string">\</span></span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      <span class="string">\</span>        /      <span class="string">\</span></span><br><span class="line"><span class="number">0</span>      _4       <span class="number">7</span>       <span class="number">9</span></span><br><span class="line">      /  <span class="string">\</span></span><br><span class="line">      <span class="number">3</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>Like decision tree. First, if one of them is root, done. Else, if root value between them, they must divided in different chile tree, so the root is the lowest common ancestor. In other word, if the root is not the middle one, they must in the same child tree, so we can use recursion to solve.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> p <span class="keyword">or</span> root <span class="keyword">is</span> q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val &lt; q.val <span class="keyword">or</span> q.val &lt; root.val &lt; p.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure>
<h1 id="No-191-Number-of-1-Bits"><a href="#No-191-Number-of-1-Bits" class="headerlink" title="No.191 Number of 1 Bits"></a>No.191 <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="external">Number of 1 Bits</a></h1><blockquote>
<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return <code>3</code>.</p>
</blockquote>
<p>Bsic problem. We can use <code>&gt;&gt;</code> operation. <code>bin</code>　it and change to char list to solve is also good way.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            tail = n % <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> tail == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h1 id="No-328-Odd-Even-Linked-List"><a href="#No-328-Odd-Even-Linked-List" class="headerlink" title="No.328 Odd Even Linked List"></a>No.328 <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="external">Odd Even Linked List</a></h1><blockquote>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>return <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
</blockquote>
<p>Inplace produce more difficuty, but the algorithm is not complex.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            odd = head</span><br><span class="line">            even_head = even = head.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> even:</span><br><span class="line">                odd.next = even.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> odd.next:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                odd = odd.next</span><br><span class="line">                even.next = odd.next</span><br><span class="line">                even = even.next</span><br><span class="line"></span><br><span class="line">            odd.next = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-137-Single-Number-2"><a href="#No-137-Single-Number-2" class="headerlink" title="No.137 Single Number 2"></a>No.137 <a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="external">Single Number 2</a></h1><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>Also use <code>set</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> (sum(set(nums))*<span class="number">3</span> - sum(nums))/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="No-96-Unique-Binary-Search-Trees"><a href="#No-96-Unique-Binary-Search-Trees" class="headerlink" title="No.96 Unique Binary Search Trees"></a>No.96 <a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="external">Unique Binary Search Trees</a></h1><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
</blockquote>
<p>Recursion is a typical solution. But it actually a mathematical problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> math.factorial(<span class="number">2</span>*n)/(math.factorial(n)*math.factorial(n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h1 id="No-141-Linked-List-Cycle"><a href="#No-141-Linked-List-Cycle" class="headerlink" title="No.141 Linked List Cycle"></a>No.141 <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">Linked List Cycle</a></h1><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>A very interesting problem. The solution is even more amazing. We establsh two pointers, a pointer move one pace each time and another is two. If there is a cycle, they must meet again.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            head1 = head</span><br><span class="line">            head2 = head.next</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> head1 <span class="keyword">is</span> head2:</span><br><span class="line">                head1 = head1.next</span><br><span class="line">                head2 = head2.next.next</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-35-Search-Insert-Position"><a href="#No-35-Search-Insert-Position" class="headerlink" title="No.35 Search Insert Position"></a>No.35 <a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">Search Insert Position</a></h1><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<p>An easy problem, <code>enumerate</code> is useful.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<h1 id="No-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#No-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="No.108 Convert Sorted Array to Binary Search Tree"></a>No.108 <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="external">Convert Sorted Array to Binary Search Tree</a></h1><blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<p>recursion is perfect.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        m = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">        root = TreeNode(nums[m])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:m])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[m+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1 id="No-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#No-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="No.116 Populating Next Right Pointers in Each Node"></a>No.116 <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></h1><blockquote>
<p>Given a binary tree<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> TreeLinkNode &#123;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *left;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *right;</span><br><span class="line">  <span class="attribute">TreeLinkNode</span> *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
</blockquote>
<p>For this situation, we could use BFS algorithm which also named scan strategy.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array = []</span><br><span class="line">            new_array = []</span><br><span class="line">            array.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">if</span> array[<span class="number">0</span>].left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">                    new_array.append(item.left)</span><br><span class="line">                    new_array.append(item.right)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new_array)<span class="number">-1</span>):</span><br><span class="line">                    new_array[i].next = new_array[i+<span class="number">1</span>]</span><br><span class="line">                array = new_array</span><br><span class="line">                new_array = []</span><br></pre></td></tr></table></figure>
<h1 id="No-230-Kth-Smallest-Element-in-a-BST"><a href="#No-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="No.230 Kth Smallest Element in a BST"></a>No.230 <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="external">Kth Smallest Element in a BST</a></h1><blockquote>
<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
</blockquote>
<p>We could use inorder search to get the kth number. The follwing is a Iterable solution using stack. Recursion is also a typical way.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        l = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            l.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            pop_num = l.pop()</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> pop_num.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                tmp = pop_num.right</span><br><span class="line">                <span class="keyword">while</span> tmp:</span><br><span class="line">                    l.append(tmp)</span><br><span class="line">                    tmp = tmp.left</span><br></pre></td></tr></table></figure>
<p>For answer the follw up problem, we should modify the raw structure of BST. We could modify the original one to inorder clue tree to get the next node easily and do not waste space. A inorde head need a extra room.</p>
<h1 id="No-83-Remove-Duplicates-from-Sorted-List"><a href="#No-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="No.83 Remove Duplicates from Sorted List"></a>No.83 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="external">Remove Duplicates from Sorted List</a></h1><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
</blockquote>
<p>A easy problem. Just take care the bounary condition.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cursor = head</span><br><span class="line">            <span class="keyword">while</span> cursor.next:</span><br><span class="line">                <span class="keyword">if</span> cursor.val == cursor.next.val:</span><br><span class="line">                    cursor.next = cursor.next.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-70-Climbing-Stairs"><a href="#No-70-Climbing-Stairs" class="headerlink" title="No.70 Climbing Stairs"></a>No.70 <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="external">Climbing Stairs</a></h1><blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p>Recursion is the first idea in my brain. It is avalaible theoretically, but the reply is error message of recurion depth limit. So, we must using iterable way.</p>
<p>The solution is like Fibonacci array.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        first = <span class="number">1</span></span><br><span class="line">        second = <span class="number">2</span></span><br><span class="line">        start = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">                first, second = second, first+second</span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure>
<h1 id="No-53-Maximum-Subarray"><a href="#No-53-Maximum-Subarray" class="headerlink" title="No.53 Maximum Subarray"></a>No.53 <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">Maximum Subarray</a></h1><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[−2,1,−3,4,−1,2,1,−5,4]</code>,<br>the contiguous subarray <code>[4,−1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<p>A typical DP(dynamic programming) problem. Just Google it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_num = max(nums)</span><br><span class="line">        <span class="keyword">if</span> max_num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max_num</span><br><span class="line">        max_of_all = max_of_tail = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            max_of_tail = max(nums[i],nums[i]+max_of_tail)</span><br><span class="line">            max_of_all = max(max_of_all, max_of_tail)</span><br><span class="line">        <span class="keyword">return</span> max_of_all</span><br></pre></td></tr></table></figure>
<h1 id="No-263-Ugly-Number"><a href="#No-263-Ugly-Number" class="headerlink" title="No.263 Ugly Number"></a>No.263 <a href="https://leetcode.com/problems/ugly-number/" target="_blank" rel="external">Ugly Number</a></h1><blockquote>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
</blockquote>
<p>A easy problem and also be cautious of Boundary condition.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> num <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isUgly(num/<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-202-Happy-Number"><a href="#No-202-Happy-Number" class="headerlink" title="No.202 Happy Number"></a>No.202 <a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="external">Happy Number</a></h1><blockquote>
<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
</blockquote>
<p>Python inside functions <code>list</code> and <code>str</code> can easily solve the problem while they are conbined.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            nums.append(n)</span><br><span class="line">            l = list(str(n))</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                n += (ord(i)<span class="number">-48</span>)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="No-326-Power-of-Three"><a href="#No-326-Power-of-Three" class="headerlink" title="No.326 Power of Three"></a>No.326 <a href="https://leetcode.com/problems/power-of-three/" target="_blank" rel="external">Power of Three</a></h1><blockquote>
<p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
</blockquote>
<p>If you use loop, everything goes well.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            i *= <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>There is a very tricky way to solve the problem without loop or recursion. We must face the fact that the problem is in computer rather than in math. The biggest number which is the power of 3 is specific. so if <code>biggest_3_power % target == 0</code>, then the target number is the ture answer.</p>
<p>No matter what is your thought, mine is WTF.</p>
<h1 id="No-89-Gray-Code"><a href="#No-89-Gray-Code" class="headerlink" title="No.89 Gray Code"></a>No.89 <a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="external">Gray Code</a></h1><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00 </span>- <span class="number">0</span></span><br><span class="line"><span class="symbol">01 </span>- <span class="number">1</span></span><br><span class="line"><span class="symbol">11 </span>- <span class="number">3</span></span><br><span class="line"><span class="symbol">10 </span>- <span class="number">2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>The key idea of this Algorithm is reduce. Once k size problem solved, we could add bit code 1 at the front of every number in the list and get a new array. Then reverse it and stick together. The new array fit Gray rule and it is the k+1 size answer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        r = self.grayCode(n<span class="number">-1</span>)</span><br><span class="line">        result = [x + (<span class="number">1</span> &lt;&lt; (n<span class="number">-1</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> r]</span><br><span class="line">        result.reverse()</span><br><span class="line">        r.extend(result)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h1 id="No-62-Unique-Paths"><a href="#No-62-Unique-Paths" class="headerlink" title="No.62 Unique Paths"></a>No.62 <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="external">Unique Paths</a></h1><blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<p>Actually a math problem. A transfomation of pascal triangle. Math solution is perfect.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> math.factorial(m+n<span class="number">-2</span>)/(math.factorial(m<span class="number">-1</span>)*math.factorial(n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<h1 id="No-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#No-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="No.153 Find Minimum in Rotated Sorted Array"></a>No.153 <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a></h1><blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>A search problem. Dichoctomizing search is the key.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l+r)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m]&gt;nums[m+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[m+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[l]:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="No-21-Merge-Two-Sorted-Lists"><a href="#No-21-Merge-Two-Sorted-Lists" class="headerlink" title="No.21 Merge Two Sorted Lists"></a>No.21 <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">Merge Two Sorted Lists</a></h1><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>A NodeList typical problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                p.next = l2</span><br><span class="line">                p = p.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = l1</span><br><span class="line">                p = p.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.next = l1</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<h1 id="No-46-Permutations"><a href="#No-46-Permutations" class="headerlink" title="No.46 Permutations"></a>No.46 <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="external">Permutations</a></h1><blockquote>
<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br><code>[1,2,3]</code> have the following permutations:<br><code>[1,2,3]</code>, <code>[1,3,2]</code>, <code>[2,1,3]</code>, <code>[2,3,1]</code>, <code>[3,1,2]</code>, and <code>[3,2,1]</code>.</p>
</blockquote>
<p>Another recursion.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">            """</span></span><br><span class="line">        <span class="keyword">return</span> self.sub(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> [[]]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> [nums]</span><br><span class="line">        pattern = self.sub(nums[<span class="number">1</span>:])</span><br><span class="line">        c = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> pattern:</span><br><span class="line">                c.append(p[:i] + [nums[<span class="number">0</span>]] + p[i:])</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
<h1 id="No-24-Swap-Nodes-in-Pairs"><a href="#No-24-Swap-Nodes-in-Pairs" class="headerlink" title="No.24 Swap Nodes in Pairs"></a>No.24 <a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="external">Swap Nodes in Pairs</a></h1><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<p>Take care of Boundary condition and other is only NodeList.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        first,second = head, head.next</span><br><span class="line">        third = second.next</span><br><span class="line">        head = second</span><br><span class="line">        second.next = first</span><br><span class="line">        first.next = self.swapPairs(third)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h1 id="No-216-Combination-Sum-3"><a href="#No-216-Combination-Sum-3" class="headerlink" title="No.216 Combination Sum 3"></a>No.216 <a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="external">Combination Sum 3</a></h1><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
</blockquote>
<p>DFS problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(k,n,index,path,result)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> <span class="keyword">not</span> k:result.append(path)</span><br><span class="line">            <span class="keyword">if</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(index,<span class="number">10</span>):</span><br><span class="line">                    dfs(k<span class="number">-1</span>,n-i,i+<span class="number">1</span>,path+[i],result)</span><br><span class="line">        result=[]</span><br><span class="line">        dfs(k,n,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数独的高效深度搜索解法]]></title>
      <url>http://migdal-bavel.in.com/2016/02/14/%E6%95%B0%E7%8B%AC%E7%9A%84%E9%AB%98%E6%95%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E8%A7%A3%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原来一直有段时间我很喜欢玩数独，尤其是沉迷于如何不用试错法来搞定一个复杂的数度问题，但是我总是被教做人。现在哥会编程了，可以用计算机教数独做人了，想想就很开心呢。</p>
<p>这篇文章是在看了Peter Norvig的一篇相关的文章后着手写的，这篇文章写的非常好，原文在<a href="http://norvig.com/sudoku.html" target="_blank" rel="external">这里</a>，翻译的版本在<a href="http://python.jobbole.com/81621/" target="_blank" rel="external">这里</a>.本文参考了其部分实现.</p>
<p>而本文的代码在我的<a href="https://github.com/Arnold-Hu/garage/blob/master/soduku/sudo.py" target="_blank" rel="external">github/garage</a>中.可以直接通过<code>git clone https://github.com/Arnold-Hu/garage.git</code>,然后再<code>python /garage/sudo.py</code>试试看.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数独的规则感觉大多数人都明白,就是横竖及小方格不能有重复的数字.那么,我们很容易就能得到一个非常显而易见的解题方法.</p>
<blockquote>
<p>当有一个数字确定时,那么与这个数字同横行,竖行以及同小方块的所有元素就不可能为那个数字.</p>
</blockquote>
<p>那么很容易能想到我们应该设计一个能体现把这些可能性表示出来的数据结构.</p>
<p>然后,通过经验我们能知道,完全靠这个规则是不能一次性解决数度问题的,对于一些较难的数独问题我们必然要试错,也就是一种深度搜索.</p>
<p>慢慢的,我们的方法就浮出了水面,每一次我们先通过已知的确定数字,把其他位置的数字试图’逼’出来.如果还有不确定数字,那么我们就开始搜索一步,也就是常说了试错一步,然后再’逼’一次,这样有三种情况:</p>
<ol>
<li><p>找到答案,游戏结束.</p>
</li>
<li><p>发现出现错误,那么表示尝试的那个数字错了,再换一个可能的数字继续’逼’.</p>
</li>
<li><p>还没错,但是还是得不到结果.那么我们就要再往下搜索一步.</p>
</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先,人生苦短,我用python.</p>
<p>然后,很容易能想到,我们可能会进行大量的测试来估计我们解法的速度,所以我们的解法应尽量快,而且显而易见的不用在乎空间的消耗.</p>
<p>所以我们的结构必须能尽量保存每次计算的结果,减少不必要的时间.我们可以做一个字典,给没一个小方格都匹配一个列表用于储存他的所有可能的取值.而且每个小方格的都独立,操作性强,而且因为是hash表的关系,读取速度非常快.</p>
<p>再者,因为空间不限,我们可以建立一个辅助数组,专门存储已经确定数字的小方格,来节省搜索以及计算列表长度的时间.</p>
<h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们先搭起一个数独的结构,因为这部分只用一次,就可以在解不同的数独中重复使用,所以不用关心写的多复杂.</p>
<p>这部分的关键部分有两个:</p>
<ol>
<li><p>建立起数独的主体结构.</p>
</li>
<li><p>建立辅助字典来得到每个小方格所对抗的方格(也就是如果这个小方格已经确定了一个数字,那么其对抗小方格则不可能出现对应数字)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'/home/arnold-hu/garage/soduku/very_hard.txt'</span> <span class="comment">#文件夹有好几个备用数独用于测试,路径需更改</span></span><br><span class="line"><span class="comment">#   initiate the structure of sudoku</span></span><br><span class="line">rows = (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>)</span><br><span class="line">cols = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>)</span><br><span class="line">types = (<span class="string">'row'</span>, <span class="string">'col'</span>, <span class="string">'block'</span>)</span><br><span class="line"></span><br><span class="line">units_belongs = &#123;&#125; <span class="comment">#过渡字典,用于表示每个小方块所属的组.</span></span><br><span class="line">control_units = &#123;&#125; <span class="comment">#过渡字典,用于表示每个组有哪些小方块.</span></span><br><span class="line"></span><br><span class="line">grids = [x+y <span class="keyword">for</span> x <span class="keyword">in</span> cols <span class="keyword">for</span> y <span class="keyword">in</span> rows]  <span class="comment">#所有小方块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立起unit_belongs字典</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> grids:</span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    units_belongs[i] = []</span><br><span class="line">    p = grids.index(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># determine the row</span></span><br><span class="line">    r = p//9</span><br><span class="line">    name = <span class="string">'row'</span> + str(r+1)</span><br><span class="line">    units_belongs[i].append(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># determine the col</span></span><br><span class="line">    c = p % 9</span><br><span class="line">    name = <span class="string">'col'</span> + str(c+1)</span><br><span class="line">    units_belongs[i].append(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  determine the block</span></span><br><span class="line">    b = r//3*3 + c//3</span><br><span class="line">    name = <span class="string">'block'</span> + str(b+1)</span><br><span class="line">    units_belongs[i].append(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  建立起control_parts字典</span></span><br><span class="line">control_parts_names = [x+y <span class="keyword">for</span> x <span class="keyword">in</span> types <span class="keyword">for</span> y <span class="keyword">in</span> rows]  <span class="comment">#控制组的名字列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> control_parts_names:</span><br><span class="line">    control_units[i] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> units_belongs:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> units_belongs[i]:</span><br><span class="line">        control_units[j].append(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键过程,通过control_parts和unit_belongs来建立对抗方格字典</span></span><br><span class="line">conter_units = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> grids:</span><br><span class="line">    conter_units[i] = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> units_belongs[i]:</span><br><span class="line">        conter_units[i].extend(control_units[j])</span><br><span class="line">    conter_units[i] = <span class="built_in">set</span>(conter_units[i])</span><br><span class="line">    conter_units[i].remove(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数独的静态部分结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立数独的主体部分</span></span><br><span class="line">units = &#123;&#125; <span class="comment">#数独主体字典</span></span><br><span class="line"></span><br><span class="line">result_units =&#123;&#125; <span class="comment">#这是一个global变量,作用在后面会注明.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> grids:</span><br><span class="line">    units[i] = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">invalid = [] <span class="comment">#用来保存所有确定的位置的列表</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>结构部分的准备就是这些,为了开心愉快的使用和调试,还需要一些准备函数:</p>
<p>用于从文件中得到数据,初始化数独结构的函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_sudo_with_file</span><span class="params">(units, path)</span>:</span> <span class="comment">#这个函数读取文件中前81个非换行符和空格的内容,若内容为1-9,则相应位置为数字,否则为空白</span></span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> rows:</span><br><span class="line">                units[grids[count]] = [i]</span><br><span class="line">                invalid.append(grids[count])</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i != <span class="string">'\n'</span> <span class="keyword">and</span> i != <span class="string">' '</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">81</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>用于显示数独的函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_sudo</span><span class="params">(units)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index,i <span class="keyword">in</span> enumerate(grids, start=<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> len(units[i]) == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'*'</span>.center(<span class="number">6</span>), <span class="comment">#6是一个魔法数字,虽然这样不好,但是为了省事还是直接用了,大多数情况下显示效果不错.</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">''</span>.join(units[i]).center(<span class="number">6</span>),</span><br><span class="line">        <span class="keyword">if</span> index % <span class="number">9</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'\n'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h3><p>首先,通过已经知道的数字把对抗方格的相应可能性消除,如果得到新的确定数字,则再消除:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_vanish</span><span class="params">(units, invalid)</span>:</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> grids:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> invalid:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> conter_units[i]:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">in</span> invalid:</span><br><span class="line">                        <span class="keyword">if</span> units[j][<span class="number">0</span>] <span class="keyword">in</span> units[i]:</span><br><span class="line">                            units[i].remove(units[j][<span class="number">0</span>])</span><br><span class="line">                            flag = <span class="keyword">True</span> <span class="comment">#当有一个可能性被消除,那么这一个循环就有收获,那么则要继续循环</span></span><br><span class="line">                            <span class="keyword">if</span> len(units[i]) == <span class="number">1</span>:</span><br><span class="line">                                invalid.append(i)</span><br><span class="line">                                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>深度搜索部分,按照前文试错法的三种可能性,来递归实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep_vanish</span><span class="params">(units, invalid)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> result_units</span><br><span class="line">    invalid_copy = invalid[:]</span><br><span class="line">    units_copy = copy.deepcopy(units)</span><br><span class="line">    tag = get_shortest_ava_unit(units_copy, invalid_copy) <span class="comment">#得到一个待定元素最少的位置</span></span><br><span class="line">    invalid_copy.append(tag) <span class="comment">#因为在递归过程中因为simple_vanish是直接作用的,所以会破坏原来的结构,需要先复制一份.</span></span><br><span class="line">    tags = units_copy[tag][:]</span><br><span class="line">    <span class="keyword">for</span> ava <span class="keyword">in</span> tags:</span><br><span class="line">        units_copy[tag] = [ava]</span><br><span class="line">        simple_vanish(units_copy, invalid_copy)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check(units_copy, invalid_copy): <span class="comment"># 有错误那么则试探下一个值</span></span><br><span class="line">            units_copy = copy.copy(units)       <span class="comment"># 下面三个语句用于回溯还原现场</span></span><br><span class="line">            invalid_copy = invalid[:]</span><br><span class="line">            invalid_copy.append(tag)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:                                   <span class="comment"># 没有错误</span></span><br><span class="line">            <span class="comment"># 没有错误的情况下,如果完成,那么直接给全局变量result_units正确的答案,然后再返回True</span></span><br><span class="line">            <span class="keyword">if</span> len(invalid_copy) == <span class="number">81</span>:</span><br><span class="line">                result_units = units_copy</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment">#如果没有结果,则进入下一层</span></span><br><span class="line">                result = deep_vanish(units_copy, invalid_copy)</span><br><span class="line">                <span class="keyword">if</span> result:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#收到False则表示下一层没有正确结果,则表示这个试探值是错的,换一个.</span></span><br><span class="line">                    units_copy = copy.copy(units)</span><br><span class="line">                    invalid_copy = invalid[:]</span><br><span class="line">                    invalid_copy.append(tag)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 所有的可能取值均不对,则此路不同,返回False通知上一层换个值试探.若为最开始层,则表示题目本身错误.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>深度搜索的部分辅助函数</strong></p>
<p>得到所有不确定位置中待定元素最少的位置:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shortest_ava_unit</span><span class="params">(units, invalid)</span>:</span></span><br><span class="line">    count = <span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> grids:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> invalid <span class="keyword">and</span> len(units[i]) &lt; count:</span><br><span class="line">            count = len(units[i])</span><br><span class="line">            short_u = i</span><br><span class="line">    <span class="keyword">return</span> short_u</span><br></pre></td></tr></table></figure></p>
<p>检验数独是否违反规则出现错误:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(units, invalid)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> invalid:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> conter_units[i]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> invalid:</span><br><span class="line">                <span class="keyword">if</span> units[i][<span class="number">0</span>] == units[j][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h3 id="打包整合"><a href="#打包整合" class="headerlink" title="打包整合"></a>打包整合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(units, invalid)</span>:</span></span><br><span class="line">    simple_vanish(units, invalid)</span><br><span class="line">    <span class="keyword">if</span> len(invalid) == <span class="number">81</span>:</span><br><span class="line">        result_units = units</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> deep_vanish(units, invalid)</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    init_sudo_with_file(units)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'*'</span>*<span class="number">20</span> + <span class="string">'原始数独'</span> + <span class="string">'*'</span>*<span class="number">20</span></span><br><span class="line">    display_sudo(units)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'*'</span>*<span class="number">20</span> + <span class="string">'解答'</span> + <span class="string">'*'</span>*<span class="number">20</span></span><br><span class="line">    <span class="built_in">if</span> solve(units, invalid):</span><br><span class="line">        display_sudo(result_units)</span><br><span class="line">    <span class="built_in">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'这个数独无解'</span></span><br></pre></td></tr></table></figure>
<p><strong>至此,算法完成.</strong></p>
<h2 id="to-do"><a href="#to-do" class="headerlink" title="to do"></a>to do</h2><ul>
<li>测试算法速度</li>
<li>生成朝鸡难的数独</li>
<li>优化算法</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python和数据库的接口简介]]></title>
      <url>http://migdal-bavel.in.com/2016/01/30/python%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>刚好最近在自学数据库，就特地写出来数据库和python连接的接口出来权当复习。现在比较流行的数据库一个是关系型数据库<strong>MySQL</strong>以及非关系型数据库，另外一个就是所谓的noSQL类型的文档数据库<strong>Mongodb</strong>。这两个都是这两方面开源软件的佼佼者，社区丰富资源多。我是不会告诉你们我只看了这俩的。</p>
<h3 id="python-MySQL接口"><a href="#python-MySQL接口" class="headerlink" title="python-MySQL接口"></a>python-MySQL接口</h3><p>首先，要安装这个接口。</p>
<blockquote>
<p><code>$sudo pip install python-mysql</code></p>
</blockquote>
<p>然后，介绍一个典型的接口实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line">conn = MySQLdb.connect(</span><br><span class="line">            db = <span class="string">'dbname'</span>,</span><br><span class="line">            user = <span class="string">'root'</span>,</span><br><span class="line">            passwd = <span class="string">'your-password'</span>,</span><br><span class="line">            host = <span class="string">'localhost'</span>,</span><br><span class="line">            charset = <span class="string">'utf8'</span>,</span><br><span class="line">            use_unicode = <span class="keyword">True</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">"truncate table xiaomihr;"</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">cursor.execute(<span class="string">"""INSERT INTO xiaomihr(item_id, work, worktype, location, hr_way)</span><br><span class="line">                        VALUES (%s, %s, %s, %s, %s)"""</span>,</span><br><span class="line">                        (</span><br><span class="line">                            item[<span class="string">'item_id'</span>],</span><br><span class="line">                            item[<span class="string">'work'</span>][<span class="number">0</span>],</span><br><span class="line">                            item[<span class="string">'worktype'</span>][<span class="number">0</span>],</span><br><span class="line">                            item[<span class="string">'location'</span>][<span class="number">0</span>],</span><br><span class="line">                            item[<span class="string">'hr_way'</span>][<span class="number">0</span>]</span><br><span class="line">                        )</span><br><span class="line">        )</span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure></p>
<p>这个程序是摘取自一个爬虫程序最后吧数据存入数据库的阶段。总的来说，这个接口就是这么几个东西：</p>
<ol>
<li>建立到数据库的连接。<code>conn = MySQLdb.connect(...)</code></li>
<li>获取数据库的游标。 <code>cursor = conn.cursor()</code></li>
<li>给出指令。 <code>cursor.exxcute(&quot;truncate table xiaomihr;&quot;)</code>,双引号括住的是要执行的SQL语句，这个SQL语句就属于另外一个方面了，这个语句的意思是把<code>xiaomihr</code>这个表清空。另外一个语句则是典型的插入数据到数据库的语句<code>cursor.execute(&quot;&quot;&quot;INSERT INTO xiaomihr(...))</code>,把相应的值插入对应的字段中。</li>
<li>提交到数据库。 <code>conn.commit()</code>,我觉得接触过ORM的人应该了解这个，就是把指令提交，通过连接传输到数据库执行，所有的操作后面一定要加这个，不然不会执行。</li>
</ol>
<p>这就是一个python-MySQL接口的典型实现。</p>
<h3 id="python-Mongodb接口"><a href="#python-Mongodb接口" class="headerlink" title="python-Mongodb接口"></a>python-Mongodb接口</h3><p>同样，第一步安装pymongo</p>
<blockquote>
<p><code>$sudo pip install pymongo</code></p>
</blockquote>
<p>第二步也是介绍一个典型实现。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line">client = MongoClient('localhost',27017)</span><br><span class="line">db = client['xiaomihr']</span><br><span class="line">collection = db['hr_imfomation']</span><br><span class="line">collection.remove()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">'item<span class="emphasis">_id' : item['item_</span>id'],</span><br><span class="line">'work' : item[<span class="string">'work'</span>][<span class="symbol">0</span>],</span><br><span class="line">'worktype' : item[<span class="string">'worktype'</span>][<span class="symbol">0</span>],</span><br><span class="line">'location' : item[<span class="string">'location'</span>][<span class="symbol">0</span>],</span><br><span class="line">'hr<span class="emphasis">_way' : item['hr_</span>way'][0]&#125;</span><br><span class="line">collection.insert(data)</span><br></pre></td></tr></table></figure></p>
<p>这个是同样上面那个程序在Mongodb接口下是实现。</p>
<ol>
<li>建立连接 <code>client = MongoClient()</code></li>
<li>选取数据库 <code>db = cliet[&#39;xiaomihr&#39;]</code>,xiaomihr是数据库的名字。</li>
<li>选取集合 <code>collection = db[&#39;hr_imfomation&#39;]</code>,hr_imformation是集合的名字（类似于MySQL里的表）。</li>
<li>然后就几乎和mongodb本身的操作一样，不需要和MySQL接口一样把指令包装成字符串再处理，pymongo直接就和在mongodb里操作一样，清空数据库就是<code>collection.remove()</code>，典型的插入数据就是<code>collection.insert(data)</code>。</li>
</ol>
<blockquote>
<p>值得注意的是，在pymongo的早期版本中和现在网上的教程中，有很多给出的实现是这样的</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">connection</span> = pymongo.Connection(<span class="string">'localhost'</span>,<span class="number">27017</span>)</span><br><span class="line"><span class="attr">db</span> = connection.test_database</span><br><span class="line"><span class="attr">collection</span> = db.test_collection</span><br></pre></td></tr></table></figure>
<p>这个在最新的版本中已经用不了了，官方给出的最佳实现是上面那个。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[暴力解决三门问题]]></title>
      <url>http://migdal-bavel.in.com/2015/12/29/%E6%9A%B4%E5%8A%9B%E8%A7%A3%E5%86%B3%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="三门问题介绍"><a href="#三门问题介绍" class="headerlink" title="三门问题介绍"></a>三门问题介绍</h1><p>我觉得大部分人应该听过这个有趣的问题，但是，一开始我还是简要的说明一下什么是三门问题。假设有一个电视节目，设置了三个一模一样的关闭着的门，其中有个门后面有辆兰博基尼作为奖品，而且每个门后面有奖品的概率相同，并且。现在你要选择一个，然后，主持人会在另外两扇门中打开一扇空门问你要不要更换选择。</p>
<blockquote>
<pre><code>换还是不换呢，这是个问题
                --Shakespeare Hu
</code></pre></blockquote>
<p>我不知道你们的第一反映是换还是不换，反正我第一次碰到这个问题的时候我觉得换不换概率是一样的。但是实际的答案告诉我我还是too young too simple。虽然我后面也自己想明白了为什么应该换，但是，违反直觉和多年以来的选择题不更改定律的东西，我心里实在是没底，所以我突然想起我可以用计算机模拟一下，简单暴力的看看到底应不应该换。</p>
<h1 id="计算机模拟"><a href="#计算机模拟" class="headerlink" title="计算机模拟"></a>计算机模拟</h1><p>python提供了非常接近于自然语言的计算机高级语言，我觉得下面的代码哪怕是没怎么学过计算机大概都能猜得到是什么意思，所以我就不注释了<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">random</span></span><br><span class="line"></span><br><span class="line">turns = <span class="number">100000</span></span><br><span class="line">doors = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">hit = &#123;'change':<span class="number">0</span>, 'unchange':<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(turns):</span><br><span class="line">    pick = <span class="built_in">random</span>.choice(doors)</span><br><span class="line">    result = <span class="built_in">random</span>.choice(doors)</span><br><span class="line">    <span class="keyword">if</span> pick == result:</span><br><span class="line">        hit['unchange'] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hit['change'] += <span class="number">1</span></span><br><span class="line">    hit_rate_change = <span class="built_in">float</span>(hit['change'])/<span class="built_in">float</span>(i+<span class="number">1</span>)</span><br><span class="line">    hit_rate_unchange = <span class="built_in">float</span>(hit['unchange'])/<span class="built_in">float</span>(i+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span> 'this <span class="built_in">is</span> the %d turns, the <span class="literal">true</span> <span class="built_in">is</span> %d, <span class="keyword">and</span> the <span class="built_in">random</span> pick <span class="built_in">is</span> %d' <span class="symbol">%</span> (i,result,pick)</span><br><span class="line">    <span class="built_in">print</span> 'the change hit rate <span class="built_in">is</span> <span class="built_in">%f</span>, <span class="keyword">and</span> the unchange one <span class="built_in">is</span> <span class="built_in">%f</span>' <span class="symbol">%</span> (hit_rate_change,hit_rate_unchange)</span><br></pre></td></tr></table></figure></p>
<p>实验了十万次后，结果是不更换的话，猜中的概率是三分之一，更换的话，猜中的概率是三分之二。现在我终于放心的可以用这个结论去装逼了。</p>
<h1 id="不暴力的解释"><a href="#不暴力的解释" class="headerlink" title="不暴力的解释"></a>不暴力的解释</h1><p>解释1： 我们用最正统最简单的概率论知识就可以得到这个违反直觉的结论。首先，你第一次选择到空门的概率是三门之二，而此时如果换门的话，必定会得到车子，而不换门一定没有车子。反过来，一开始如果你很幸运，以三分之一的概率选到了有车子的那个门，那么换门的话到嘴的鸭子就飞了，而坚持选择，你就得到了车子。<br>那么很显然的，不换门得到兰博基尼的概率是：2/3 × 0 + 1/3 × 1 = 1/3<br>而换门得到兰博基尼的概率是：2/3 × 1 + 1/3 × 0 = 2/3<br>和我们模拟出来的结果相同。</p>
<p>解释2： 因为自己选的门只有三分之一的概率正确，那么剩下那个就是三分之二。</p>
<p>解释3： 因为主持人开空门这个行为并不是随机的。</p>
<h1 id="三门问题的小花边"><a href="#三门问题的小花边" class="headerlink" title="三门问题的小花边"></a>三门问题的小花边</h1><p>三门问题其实正式点的称呼是“蒙提霍尔问题”（Monty Hall dilemma），来自 Craig F. Whitaker 于1990年寄给《展示杂志》（Parade Magazine）玛丽莲·沃斯·莎凡特（Marilyn vos Savant）专栏的信件。玛丽莲·沃斯·莎凡特在她专栏的回答是改选会更有优势，这在美国引起了激烈的争议：人们寄来了数千封抱怨信，很多寄信人是科学老师或学者。一位来自佛罗里达大学的读者写道：“这个国家已经有够多的数学文盲了，我们不想再有个世界上智商最高的人来充数！真让人羞愧！”另一个人写道：“我看你就是那只山羊！”美国陆军研究所(US Army Research Institute)的埃弗雷特·哈曼(Everett Harman)写道，“如果连博士都要出错，我看这个国家马上要陷入严重的麻烦了。”<br>这说明我的智商和很多美国教授是一个水平的，我非常开心。</p>
<h1 id="类似的小问题"><a href="#类似的小问题" class="headerlink" title="类似的小问题"></a>类似的小问题</h1><p>还有一个很有意思的信封问题，大致是这样的：<br>有一天一个程序员去领奖金，他老板给他凑了个整，放了1024元在信封里。而且，老板神秘兮兮的和猿说：“我给你一个额外的bonus，我手里还有另外一份奖金，是你手里的两倍或者二分之一，每种可能的概率相同，你要不要换一份。”猿想了一会，算了算数学期望，（2+0.5）/2=1.25，然后高呼老板万岁，换了一份。然后老板又说：“你要是觉得亏了还可以换回来，我把信封放在这里，先回去了。”然后，程序员不小心又算了一下期望。。。<br>第二天，老板回办公室的时候，发现程序猿同学还在算期望中。<br>大家觉得应该怎么换比较好，这个一直换的程序猿同学到底哪里错了呢。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[让我们来研究一下神奇的连连看]]></title>
      <url>http://migdal-bavel.in.com/2015/09/26/%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E7%A5%9E%E5%A5%87%E7%9A%84%E8%BF%9E%E8%BF%9E%E7%9C%8B/</url>
      <content type="html"><![CDATA[<p>找个小游戏来学习练习一下构建模型，练练看结构简约而不简单，刚刚好，就拿来练练手，下一期说不定是数独，我觉得那个也挺有意思的~</p>
<p>在下面的文章里，把连连看里的小方快都叫做<strong>结点</strong>，这样能够统一数据结构和通俗的叫法，不易混淆。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>我们可以总结一下连连看这个游戏的规则来构建模型：</p>
<ol>
<li>当所有的结点都被消去时，游戏结束。</li>
<li>两个结点之间如果图案相同而且存在一条路径上没有其他结点，而且这条路径转弯的粗书不超过两次，那么这两个结点称为相连的。</li>
<li>相连的结点可消去，消去后所在位置为空。</li>
<li>当不存在相连结点并且还有结点存在时，称为死锁状态，应自动调换所有结点的位置。</li>
</ol>
<p>那么，根据连连看的规则，这个游戏只有三个状态：</p>
<ol>
<li>存在可以连的结点。</li>
<li>死锁状态。</li>
<li>没有结点，游戏结束。</li>
</ol>
<p>而这三种状态之间的转换只有两种可能：</p>
<ol>
<li>消去了一对结点。</li>
<li>没有可以消去的结点，随机调整。</li>
</ol>
<p>下面是这个有限状态机的示意图：<br><img src="http://7xl294.com1.z0.glb.clouddn.com/连连看状态机.png" alt=""></p>
<p>这个是详细的流程图：<br><img src="http://7xl294.com1.z0.glb.clouddn.com/连连看算法示意图.png" alt=""></p>
<p>这样，一个连连看的核心模型就完成了。</p>
<p>然后我们就可以继续搞定数据结构和算法了。</p>
<h1 id="数据结构及存储"><a href="#数据结构及存储" class="headerlink" title="数据结构及存储"></a>数据结构及存储</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>完成连连看所需要的数据无非是每个图的图像和位置，那么我们如果把每个连连看看里的图像当成结点，那么每个结点应该至少有位置和内容。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>因为结点的位置不会发生变动，所以最省资源的还是静态的数组，在python里可以用双重列表。</p>
<p>然后对于图像而言，可以建立一个索引来指向图像，那么数组的元素保存图像的索引就可以完成对连连看的数据结构的存储。</p>
<p>当然，因为连连看需要的空间小，而且程序所要求的速度性能非常低，任性点直接每个节点都存储位置和图像，然后直接把结点随意塞到一个数组里也是一点问题都没有的。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>我们在流程图中可以看到，整个的过程就是两个判断和两个流程，我们的算法也就是实现这四个家伙，在这里我们只是考虑如何实现这些流程，到后面再来考虑如何做优化。</p>
<ul>
<li>实现消去一个对子</li>
<li>实现调整位置</li>
<li>判断是否还有结点</li>
<li>判断是否死锁</li>
</ul>
<hr>
<p>下面我们来一个个讨论如何实现</p>
<p><strong>实现消去一对结点</strong></p>
<p>这里面最重要的算法就是计算两个结点之间能不能连通，这个有很多实现方法。我先抛砖引玉说一种思路。</p>
<blockquote>
<p>遍历一个结点能连通的所有位置，每遍历一个位置观察对应结点是不是在这个位置上。</p>
</blockquote>
<p>由规则2我们知道，连连看规则是连线之间不能有其他结点，并且路线不能弯折超过两次。</p>
<p>那么路线就可以分为三种层次–没有弯折，弯折一次，弯折两次。可以用一个高度不超过3的树来表示这种结构。既然可以用树来表达，那么我们就可以用树的深度优先搜索和广度优先搜索了。</p>
<p>如果用广度优先，那么我们先可以先找出所有不用弯折就可以到达的位置，把这些位置存着，如果这途中没有找到，那么这些点重复上面的步骤，找出所有弯折一次能到的位置，如果没找到，再重复。如果还没找到，那么就表示无法连通。</p>
<p><strong>确定死锁</strong></p>
<p>我们既然是学贵数学的，就应该把这个问题转化成已经解决过的问题。比如，我们可以很粗暴的直接遍历所有剩下的结点，看看是否都没有相连的结点。如果都没有，那么就表示死锁了。</p>
<p><strong>判断是否还有节点</strong></p>
<p>这个看数据结构，如果用的是数组的话，那么遍历整个数组，看看是不是每个位置都是空的。</p>
<p><strong>调整</strong></p>
<p>每次随机选出两个还有结点的位置，交换这两个位置的图案。</p>
<p>这样模型，结构和算法都已经完成了，然后我们就可以开始码代码测试了。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这个连连看的demo已经实现了，只有最简陋的运行在命令行的程序，没有任何美化。不过所有的基础功能都已经实现了，算是连连看1.0完成了吧。</p>
<p>程序的python文件在我的<a href="https://github.com/Arnold-Hu/garage/blob/master/lianliankan/simple_lianlian.py" target="_blank" rel="external">github/garage/lianliankan</a>里,随便你复制粘贴或者clone代码都行，只有那一个文件。</p>
<p>这个文件可以直接import，开始游戏的那一段已经通过<code>if __name__ == &#39;__main__&#39;</code>给限定在测试用，当你把这个文件当模块用的时候，这部内容会自动忽略。</p>
<p>因为是1.0版，所以这个版本的实现可以说是非常仓促，没有任何优化，甚至为了通过测试，很多地方都冗余了，后面有时间会慢慢改进。</p>
<p>程序里注释了每个函数的功能，结合上说过的算法很容易知道整个运行逻辑。</p>
<p>ps：果然写一整个小项目的过程比写一个算法烦多了。。。第一次用pycharm来排bug。难得一次写几百行，还是这么简单的玩具代码，想想以后要写的东西，任重道远啊～</p>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li>代码实现  done</li>
<li>效果展示</li>
<li>优化的思考<br>++ 如何实现提示功能<br>++ 能不能优化搜索路径的步骤使得不需要每次判断相连都要重新搜索<br>++ 如何快速的确定死锁<br>++ 如何快速的判断是否还有结点<br>++ 如何减少执行这个程序需要的内存</li>
</ul>
<p>其实对于上面的小程序，上面的优化都毫无必要，但是我们还是把他当成一个大工程来想想，锻炼一下～</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用python实现kmeans算法]]></title>
      <url>http://migdal-bavel.in.com/2015/09/20/%E7%94%A8python%E5%AE%9E%E7%8E%B0kmeans%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近准备找些东西练练手，就想着实现一下一些数据处理方面的算法，一方面是可以更深刻的理解算法，二也能锻炼一下编程水平。这一次编写kmeans算法的时候就出现了很多很神奇的bug，有一些还是python这种弱类型语言所特有的，很这么人也很有意思。</p>
<h1 id="K-means算法介绍"><a href="#K-means算法介绍" class="headerlink" title="K-means算法介绍"></a>K-means算法介绍</h1><p>K-means算法是一种非常常用也很有效的聚类算法。这个算法能够把一个数据集以一个定义好的距离为度量划分成k个子集，而且其实简单，所以地一个用来练手。</p>
<p>具体的内容见<a href="http://baike.baidu.com/link?url=hFqIy4gnmEDas7Qg6ENbKhUPmU-cpe-RxMZdYgg4M6L6jvRoALZXaWZtwnf3uKDXKFDxSwJD5laYVMMgEcGuQK" target="_blank" rel="external">百度百科的k-means</a>。</p>
<h1 id="k-means算法流程"><a href="#k-means算法流程" class="headerlink" title="k-means算法流程"></a>k-means算法流程</h1><ol>
<li>选取k个初始点作为中心点，一般是在数据集中最忌选择k个。</li>
<li>计算数据集中所有点到中心点的距离，并选择距离最短的那个中心点，这样就把所有的点分成了k个子集。</li>
<li>在这k个子集中选出每个自己的中点作为新的中心点。</li>
<li>然后再迭代进行步骤2,直到这k个中心点不发生变化。这样就得到了k个中心点和k个类。</li>
</ol>
<h1 id="k-means算法的实现"><a href="#k-means算法的实现" class="headerlink" title="k-means算法的实现"></a>k-means算法的实现</h1><p>下面给出k-means算法的主干部分，这个算法的<a href="https://github.com/Arnold-Hu/garage/blob/master/kmeans.py" target="_blank" rel="external">代码文件</a>在我的github的garage中。<br>目前功能非常简单，只能实现点集以欧式距离为度量聚类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span><span class="params">(dataset, k=<span class="number">2</span>, demension=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化，dataset是要分类的数据集，demension是维度</span></span><br><span class="line">    empty_set = []   <span class="comment">#制造一个[[],[],...,[]]来方便其他列表的初始化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        empty_set.append([])</span><br><span class="line">    centers = []     <span class="comment">#centers数组存放中心点</span></span><br><span class="line">    residation = [<span class="number">10</span>]*k    <span class="comment">#residation数组存放两次中心点向量之差</span></span><br><span class="line">    temp = [<span class="number">0</span>] * k    <span class="comment">#temp数组存放到每个中心点的距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):  <span class="comment">#把数据集的前k个点作为初始中心点</span></span><br><span class="line">        centers.append(dataset[i])</span><br><span class="line">    <span class="comment"># 开始正式迭代</span></span><br><span class="line">    <span class="keyword">while</span>(sum(residation)&gt;<span class="number">0.0001</span>):</span><br><span class="line">        divide_set = copy.deepcopy(empty_set) <span class="comment">#初始化子集列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dataset: <span class="comment">#遍历数据集的所有数据</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k): <span class="comment">#计算到每个中心点的距离</span></span><br><span class="line">                temp[j] = distance(i, centers[j], demension)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k): <span class="comment">#划分到所属的子类中</span></span><br><span class="line">                <span class="keyword">if</span> temp[j] == min(temp):</span><br><span class="line">                    divide_set[j].append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k): <span class="comment">#得到新的中心点和新旧中心点之间的差</span></span><br><span class="line">            residation[j] = distance(get_center(divide_set[j]), centers[j])</span><br><span class="line">            centers[j] = copy.deepcopy(get_center(divide_set[j]))</span><br><span class="line">    <span class="comment">#算法完成，返回中心点和划分出的子类</span></span><br><span class="line">    <span class="keyword">return</span> [centers,divide_set]</span><br></pre></td></tr></table></figure></p>
<p>算法的实现方法都在注释里说明了，剩下的辅助函数如下</p>
<ul>
<li><p>计算子类的中心点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_center</span><span class="params">(dataset)</span>:</span></span><br><span class="line">    dem = len(dataset[<span class="number">0</span>])</span><br><span class="line">    point = [<span class="number">0.0</span>] * dem</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dataset:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dem):</span><br><span class="line">            point[j] += i[j]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(dem):</span><br><span class="line">        point[j] = point[j] / len(dataset)</span><br><span class="line">    <span class="keyword">return</span> tuple(point)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算两个点之间的距离</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(point1, point2, demension=<span class="number">2</span>)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(demension):</span><br><span class="line">        sum = sum + (point1[i] - point2[i])*(point1[i] - point2[i])</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>说了这个算法很简单。。。</p>
<h1 id="k-means效果"><a href="#k-means效果" class="headerlink" title="k-means效果"></a>k-means效果</h1><p>同样在github/garage中有一个测试这个算法的的测试文件<a href="https://github.com/Arnold-Hu/garage/blob/master/test_kmeans.py" target="_blank" rel="external">test_kmeans.py</a>，没有按照单元测试的写法那么严格，主要是为了作出效果图顺便练练做图。<br>效果图如下：<br><img src="http://7xl294.com1.z0.glb.clouddn.com/test_kmeans.png" alt=""></p>
<h1 id="有关的bug"><a href="#有关的bug" class="headerlink" title="有关的bug"></a>有关的bug</h1><ul>
<li>列表中的列表的复制</li>
</ul>
<blockquote>
<p>python中的list变量是一个指针，如果单纯用a=b之恩那个让a和b同时指向一个list。</p>
</blockquote>
<p>列表的内容复制有几种方法，比如<code>a=b[:]</code>,<code>a=copy.copy(b)</code>,其中使用copy需要加载copy模块<code>import copy</code>。但是这两种方法只能复制简单列表，即列表的元素只能是基本元素，而不能是类似列表这种元素，举个例子：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="comment">[1,2,<span class="comment">[3,4]</span>]</span></span><br><span class="line">b=a<span class="comment">[:]</span></span><br><span class="line">a<span class="comment">[2]</span>.append(5)</span><br><span class="line">print b</span><br></pre></td></tr></table></figure></p>
<p>结果输出是<code>[1,2,[3,4,5]]</code><br>而要真正的复制所有内容，就需要用深拷贝。<br><code>a=copy.deepcopy(b)</code><br>这样能够迭代这把所有b中的元素拷贝到a中并且不会互相干涉。</p>
<ul>
<li>[ [ ] ]*k</li>
</ul>
<p>在算法中我用的是<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty_set = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        empty_set.<span class="built_in">append</span>([])</span><br></pre></td></tr></table></figure></p>
<p>来制造一个空的list of list.</p>
<p>其实在一开始我用的是<br><code>empty_set = [[]]*k</code></p>
<p>虽然看起来很简便，但是之后我发现程序有个很逗逼的bug，就是无论我往emptyset里面的那个子listappend元素，里面每个子列表都会添加同一个元素。花了很久的时间我才发现这个问题。其实这个问题和上面那个差不多，只不过更加隐蔽。这也和python很灵活有很大关系，同时提醒自己要更深入的了解原理减少再出现这种难以发现的bug的机会。</p>
<p>虽然直接用乘法隐藏着隐患，但是用来初始化一些基本的元素里表还是很有用的，比如[0]*10就能够直接初始化一个长度为10元素值均为0的列表。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一定要养成备份文件的好习惯，防止手贱]]></title>
      <url>http://migdal-bavel.in.com/2015/08/22/%E4%B8%80%E5%AE%9A%E8%A6%81%E5%85%BB%E6%88%90%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%89%8B%E8%B4%B1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>重要的程序和项目一定要及时备份！！！！！！</p>
</blockquote>
<p>今天准备换win10用，因为我的windows是装在固态硬盘上，导致系统盘的空间一直很紧张，然后因为升级win10时需要系统盘空余空间，所以我把一些配置转移到data盘想空出空间来，结果不小心把windows的身份文件给转移了，之后就无法成为管理员，崩溃了。</p>
<p>之后只能重装了一个win10系统，然后我突然发现win10把我原来装ubuntu的那另外一个硬盘也给覆盖了，我感觉这个事情顿时就大条了。所有在ubuntu的数据全部消失。</p>
<p>还好在github上还有一些重要项目，但是个人主页的源文件我也丢失了，只能重新配置，把那些文章从html还要转回markdown格式再生成新的页面。。。简直酸爽。</p>
<p>ubuntu上配置的各种开发环境全部都要重新再配置一遍，虽然已经比较熟悉了，但是还是花了非常多的时间。</p>
<p>所以，总结教训。</p>
<ul>
<li>一定要把重要的程序和项目备份，不管是备份到云端还是u盘什么的</li>
<li><strong>不要手贱！</strong></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于scrapy的爬虫的快速上手教程----以内推网为例]]></title>
      <url>http://migdal-bavel.in.com/2015/08/22/%E5%9F%BA%E4%BA%8Escrapy%E7%9A%84%E7%88%AC%E8%99%AB%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B-%E4%BB%A5%E5%86%85%E6%8E%A8%E7%BD%91%E4%B8%BA%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>本篇文章是一篇快速构造爬虫的教程。目的是尽量在最短的时间内构建一个能满足大部分需求的爬虫。目标人群是想通过爬虫自动一些网站上的信息以助于完成工作但是并不想深入了解爬虫的朋友。而且如果能快速的通过自己学到的东西作出成果，我相信大家会对学习保持充足的热情与兴趣。<br>本文的爬虫可以去我的github的<a href="https://github.com/Arnold-Hu/neitui_spider" target="_blank" rel="external">neitui_spider</a>项目上看。</p>
<h1 id="为什么要写这个教程"><a href="#为什么要写这个教程" class="headerlink" title="为什么要写这个教程"></a>为什么要写这个教程</h1><p>现在大数据这么时髦对吧，我们也应该赶一下潮流啊，说出去也很有范对不对，别人分分钟以为你是一个Data Scientist，倍儿有面子。但是,问题来了，搞这个大数据从哪里下手呢？</p>
<ul>
<li>先弄到数据，用人工，用爬虫，问朋友，派间谍，随意。</li>
<li><p>整理数据或者说清洗数据</p>
<blockquote>
<p>Data is dirty</p>
<pre><code>----   by all data scientist
</code></pre></blockquote>
</li>
<li><p>把数据存入数据库</p>
</li>
<li><p>分析数据 得出结论</p>
</li>
<li>可视化</li>
</ul>
<p>上面是我草率的步骤分类，每一个方面都有很多值得研究。<br>你看，最上游的就是得到数据，而得到数据里面最有意思的就是用爬虫了~这样写爬虫的时候顿时就有一种当产业大佬的感觉，会大大加快你的码代码效率的～</p>
<h1 id="安装scrapy"><a href="#安装scrapy" class="headerlink" title="安装scrapy"></a>安装scrapy</h1><p>这是<a href="http://scrapy-chs.readthedocs.org/zh_CN/1.0/intro/install.html" target="_blank" rel="external">scrapy的中文安装文档</a>，按照文档上的方法装一般是能够装好的。<br>然后还需要<a href="http://ipython.org/install.html" target="_blank" rel="external">安装ipython</a>来方便进行调试。<br>因为我的ubuntu系统已经安装过了python的环境所以只需要<br><code>$ sudo easy_install pip</code><br><code>$ pip install scrapy</code><br><code>$ pip install ipython</code><br>就行了。其他的系统把pip安装好可以一样很方便的安装。</p>
<h1 id="clone项目"><a href="#clone项目" class="headerlink" title="clone项目"></a>clone项目</h1><p>如果你还没有安装git并且注册github的话，请先<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="external">安装git</a>并且<a href="github.com">注册github</a><br>然后你之需要把我的项目clone一下就可以了<br><code>$ git clone https://github.com/Arnold-Hu/neitui_spider.git</code><br>这就会在目录下生成一个<a href="www.neitui.me">内推网</a>的爬虫项目，然后我再通过这个项目介绍一些写爬虫最关键的部分。</p>
<h1 id="爬虫的配置"><a href="#爬虫的配置" class="headerlink" title="爬虫的配置"></a>爬虫的配置</h1><h2 id="item-py文件"><a href="#item-py文件" class="headerlink" title="item.py文件"></a>item.py文件</h2><p>item.py文件的位置在neitui_spider/neituiwang/neituiwang/item.py的位置。<br>item.py文件的主要作用就是告诉scrapy框架你要爬的内容。<br>比如在我的item.py中，部分内容是这样的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">class</span> <span class="type">NeituiwangItem</span>(<span class="title">scrapy</span>.<span class="type">Item</span>):</span><br><span class="line">    page_id = scrapy.<span class="type">Field</span>()</span><br><span class="line">    person = scrapy.<span class="type">Field</span>()</span><br><span class="line">    date = scrapy.<span class="type">Field</span>()</span><br><span class="line">    work = scrapy.<span class="type">Field</span>()</span><br><span class="line">    salary = scrapy.<span class="type">Field</span>()</span><br><span class="line">    experience = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company = scrapy.<span class="type">Field</span>()</span><br><span class="line">    address = scrapy.<span class="type">Field</span>()</span><br><span class="line">    tag = scrapy.<span class="type">Field</span>()</span><br><span class="line">    # requirement = scrapy.<span class="type">Field</span>()</span><br><span class="line">    name = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company_link = scrapy.<span class="type">Field</span>()</span><br><span class="line">    city = scrapy.<span class="type">Field</span>()</span><br><span class="line">    homepage = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company_size = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company_field = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company_finance = scrapy.<span class="type">Field</span>()</span><br><span class="line">    company_hope = scrapy.<span class="type">Field</span>()</span></span><br></pre></td></tr></table></figure></p>
<p>我在内推网中想要爬的就是页面id、发布人、发布时间、招聘职位、薪水等内容。其中requirement被我注释掉了，因为职位需求内容比较多，得到的数据不好分析，需要的话可以去掉注释。<br>你如果有什么想爬的内容，都需要先在item.py文件中”备案“。格式是<br><code>content = scrapy.Field()</code></p>
<h2 id="锁定目标网页"><a href="#锁定目标网页" class="headerlink" title="锁定目标网页"></a>锁定目标网页</h2><p>除了item.py之外剩下的配置都在neitui_spider/neituiwang/neituiwang/spiders/neituiwangspider.py中。<br>我们来看锁定目标网页的部分<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">"neituiwang"</span></span><br><span class="line">    <span class="attr">allowed_domains</span> = [<span class="string">"neitui.me"</span>]</span><br><span class="line">    <span class="attr">start_urls</span> = [<span class="string">"http://www.neitui.me/neitui/type=all.html"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">rules</span> = [</span><br><span class="line">        Rule(LinkExtractor(<span class="attr">allow=('\?name=job&amp;handle=detail&amp;id=\d&#123;6&#125;&amp;from=index')),</span> <span class="attr">follow=False,</span> <span class="attr">callback='parse_item'),</span></span><br><span class="line">        Rule(LinkExtractor(<span class="attr">allow=('/neitui/type=all&amp;page=\d+\.html',)),</span> <span class="attr">follow=True)</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>name</strong>是你的爬虫的名字，启动爬虫的时候输入的就是这个。</li>
<li><p><strong>allowed_domains</strong>是限定的域名，让你的爬虫只能在这个域名中工作，比如这个爬虫就只能在内推网中工作，如果爬取到了指向其他网页比如招聘公司的主页则不会跟进。</p>
<blockquote>
<p>注意，限制域名中不要在前面加www之类的二级域名前缀。</p>
</blockquote>
</li>
<li><p><strong>start_urls</strong>则是你的爬虫开始的网页，怎么方便怎么来，前提是要在allowed_domain中。比如在内推网中，可以在最新职位那个页面比较方便的解析得到所有的招聘职位信息，那么我就用这个网址。<br>如果你要找的网址比较分散，可以加入多个start_url，比如<br><code>start_url = [&quot;www.baidu.com&quot;, &quot;www.google.com&quot;, &quot;migdal-bavel.in&quot;]</code><br>其实在allowed_domain中同样，加入多个限制域名后只要满足其中一个都进行跟进解析。</p>
</li>
<li><p><strong>rules</strong>告诉框架如何选择那些网址需要跟进，哪些网址需要解析，具体的见<a href="http://scrapy-chs.readthedocs.org/zh_CN/1.0/topics/spiders.html#crawling-rules" target="_blank" rel="external">官方文档</a>。<br>scrapy会把所在的页面的所有链接都识别出来然后再根据这些rules进行操作。<br>最常用rules的就是上面两种</p>
</li>
</ul>
<ol>
<li><p>rule1 ——<code>Rule(LinkExtractor(allow=(&#39;\?name=job&amp;handle=detail&amp;id=\d{6}&amp;from=index&#39;;)), follow=False, callback=&#39;parse_item&#39;)</code><br>负责解析页面，其中</p>
<ul>
<li><code>LinkExtractor(allow=(&#39;\?name=job&amp;handle=detail&amp;id=\d{6}&amp;from=index))</code>表示把满足allow中的正则表达式的网页提取出来。这个正则表达式中<code>\d{6}</code>表示匹配任意6个数字，其他则是原本的意思，比如这个表达式会匹配网址为<code>http://www.neitui.me/?name=job&amp;handle=detail&amp;id=404937&amp;from=index</code>这样的页面。</li>
<li><code>follow = false</code> 表示对提取出来的网页不跟进，也就是不再对提取出来的网页中的链接通过rules进行处理，换句话说，爬虫在这里到头了。</li>
<li><code>callback = &#39;parse_item&#39;</code> 表示把解析出来的网页传回给 parse_item 函数进行处理，也就是要在这个页面提取我们要的信息。</li>
</ul>
</li>
<li><p>rule2 ——<code>Rule(LinkExtractor(allow=(&#39;/neitui/type=all&amp;page=\d+\.html&#39;,)), follow=True)</code><br>负责跟进页面，其中</p>
<ul>
<li><code>LinkExtractor(allow=(&#39;/neitui/type=all&amp;page=\d+.html&#39;,))</code>  和上面那个一样，同样是正则表达式来过滤链接。其中<code>\d+</code>指的是贪心匹配至少一个数字，<code>\.</code>表示匹配’.’。例子：<code>http://www.neitui.me/neitui/type=all&amp;page=1.html</code>。</li>
<li><code>follow=True</code> 表示会过滤提取出来的网页中的所有链接再次通过rules解析，换句话说，爬虫还会继续往下走。<br>而这里因为没有我们需要的信息，所以我们没有用callback参数，如果你需要在这个页面中提取一些信息的话，可以再加上这个。比如如果你在下面还有一个解析页面的parse_page函数的话，可以再加上<code>callback = &#39;parse_page&#39;</code>。</li>
</ul>
</li>
</ol>
<h2 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h2><p>我们来看看提取信息的部分<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def parse_item(self, response):</span><br><span class="line">        base = response.xpath(<span class="string">'//div[@class="cont"]'</span>)</span><br><span class="line">        company_part = response.xpath(<span class="string">'//div[@class="plate company_information"]'</span>)</span><br><span class="line">        item = <span class="symbol">NeituiwangItem</span>()</span><br><span class="line">        item[<span class="string">'page_id'</span>] = response.xpath(<span class="string">'//div[@class="handlerbar clearfix"]/a[1]/@href'</span>).re(<span class="string">'\d&#123;6&#125;'</span>)</span><br><span class="line">        item[<span class="string">'person'</span>] = base.xpath(<span class="string">'div[1]/a[1]/text()'</span>).extract()  </span><br><span class="line">        item[<span class="string">'date'</span>] = base.xpath(<span class="string">'div[1]/text()'</span>).re(<span class="string">'\d&#123;2&#125;.\d&#123;2&#125;.'</span>)</span><br><span class="line">        item[<span class="string">'work'</span>] = base.xpath(<span class="string">'div[2]/strong/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'salary'</span>] = base.xpath(<span class="string">'div[2]/span[1]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'experience'</span>] = base.xpath(<span class="string">'div[2]/span[2]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'company'</span>] = base.xpath(<span class="string">'div[3]/span[1]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'address'</span>] = base.xpath(<span class="string">'div[3]/span[2]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'tag'</span>] = base.xpath(<span class="string">'div[4]//ul/li/span[1]/text()'</span>).extract()</span><br><span class="line">        # item[<span class="string">'requirement'</span>] = base.xpath(<span class="string">'div[6]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'name'</span>] = company_part.xpath(<span class="string">'div[1]/div[2]/a/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'company_link'</span>] = <span class="string">"www.neitui.me"</span> + company_part.xpath(<span class="string">'div[1]/div[2]/a/@href'</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'city'</span>] = company_part.xpath(<span class="string">'dl[1]/dd[1]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'homepage'</span>] = company_part.xpath(<span class="string">'dl[1]/dd[2]/a/@href'</span>).extract()</span><br><span class="line">        item[<span class="string">'company_size'</span>] = company_part.xpath(<span class="string">'dl[2]/dd[1]/text()'</span>).extract()    </span><br><span class="line">        item[<span class="string">'company_field'</span>] = company_part.xpath(<span class="string">'dl[2]/dd[2]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'company_finance'</span>] = company_part.xpath(<span class="string">'dl[2]/dd[3]/text()'</span>).extract()</span><br><span class="line">        item[<span class="string">'company_hope'</span>] = company_part.xpath(<span class="string">'dl[3]/dd/text()'</span>).extract()</span><br><span class="line">        yield item</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们就需要把一个个在item.py那里挖的坑填进去了。<br>因为我们之需要对一种页面进行解析，所以我们只写了一种解析函数．在解析函数中，我们通过<strong>选择器</strong>来提取我们需要的信息，而使用选择器最关键的就是要会用Xpath和正则表达式．<br>简而言之，Xpath是通过html中的标签进行对信息的过滤。<strong>这个一定要自己学会才能熟练的使用爬虫</strong>。<br><a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="external">Xpath教程</a><br><a href="http://scrapy-chs.readthedocs.org/zh_CN/1.0/intro/tutorial.html#id5" target="_blank" rel="external">简介scrapy中的提取方法</a><br><a href="http://scrapy-chs.readthedocs.org/zh_CN/1.0/topics/selectors.html" target="_blank" rel="external">选择器的正式文档</a><br>光是看这个教程肯定很枯燥，但是因为我们已经安装过了ipython，所以我们可以交互式的来验证我们所学的内容，我们需要打开scrapy shell<br><code>scrapy shell url</code><br>其中url是你需要解析的网站，比如我们想解析内推网第一页的招聘信息只需要<br><code>scrapy shell &quot;http://www.neitui.me/neitui/type=all&amp;page=1.html&quot;</code></p>
<blockquote>
<p>注意！url要加引号，不然url中的一些符号会错误解析。</p>
</blockquote>
<p>然后我们就可以愉快的玩耍了，我相信平时使用Matlab和R的同学会很喜欢这种界面的。<br>举一个例子<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">base</span> = response.xpath(<span class="string">'//div[@class="cont"]'</span>)</span><br><span class="line">item[<span class="string">'person'</span>] = <span class="keyword">base</span>.xpath(<span class="string">'div[1]/a[1]/text()'</span>).extract()</span><br><span class="line">item[<span class="string">'date'</span>] = <span class="keyword">base</span>.xpath(<span class="string">'div[1]/text()'</span>).re(<span class="string">'\d&#123;2&#125;.\d&#123;2&#125;.'</span>)</span><br></pre></td></tr></table></figure></p>
<p>base是作为一个通用的路径表示所有属性class=”cont”的div标签中的内容<br>item[‘person’] 表示在base路径下第一个div标签中的第一个a标签中的文本内容(若text()改为@href则表示是a中的href链接)<br>item[‘date’] 表示在base路径下地一个div标签中的文本内容中符合正则表达式的部分(\d{2}表示匹配两个数字，.表示匹配任意一个字符，和起来是为了匹配如同08月03日这种内容)</p>
<p>至此，爬虫就搭建完了。</p>
<h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>然后输入<br><code>scrapy crawl spidername -o filename.csv</code><br>必须在爬虫的目录里(neitui_spider/neituiwang/)运行这个命令，建议在爬虫的根目录中运行。</p>
<ul>
<li>spidername是你爬虫的名字，在这里是neituiwang</li>
<li>filename是你要存放数据的文件的名字，存放数据可以有几种文件格式，比如csv，json。按照我们的目标人群，建议用csv，方便excel处理。</li>
</ul>
<h2 id="等爬虫"><a href="#等爬虫" class="headerlink" title="等爬虫"></a>等爬虫</h2><p>爬虫是需要时间爬的，我运行的时候差不多用了一个小时，爬出来了30000+条记录。可以直接在<a href="https://github.com/Arnold-Hu/neitui_spider/blob/master/neituiwang/data.csv" target="_blank" rel="external">这里</a>查看我爬出来的记录，因为过了一段时间，可能和最新的有所不同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>爬虫的工作方法就是从一个网页开始，根据特定的规则通过一个个链接探索网页，然后提取出每个页面中我们需要的信息。<br>那么，从这个思路我，我们回顾一下我们要配置的那些基本内容。</p>
<ul>
<li><strong>从一个网页开始</strong><br>我们提供start_urls来提供初始页面，通过allowed_domain给出整张网的大小。</li>
<li><strong>根据特定的规则探索</strong><br>我们在rules里面配置规则告诉爬虫应该怎么探索网络。</li>
<li><strong>提取页面</strong><br>我们通过选择器配合Xpath来告诉爬虫应该提取那些信息。</li>
<li><strong>我们需要的信息</strong><br>我们通过item.py里的项目告诉爬虫这些信息是什么或者说该填入那个坑里面。</li>
</ul>
<h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用github page以及hexo模板建立个人独立博客]]></title>
      <url>http://migdal-bavel.in.com/2015/08/22/%E5%88%A9%E7%94%A8github-page%E4%BB%A5%E5%8F%8Ahexo%E6%A8%A1%E6%9D%BF%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>折腾了几天终于把这个个人博客建立起来了，因为不会前端技术所以就利用别人的模板来偷懒做个主页。趁着现在还没有忘掉把这个过程记录下来，中间走了不少弯路大家可以借鉴一下。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><blockquote>
<p>所有的工具的使用方法一律以官方文档为主<br>所有的工具的使用方法一律以官方文档为主<br>所有的工具的使用方法一律以官方文档为主</p>
</blockquote>
<p>重要的事情说三遍，因为我建博客的时候被坑了好几次了。当时找到的教程用的hexo和其他的依赖版本都和现在不一样，有些过程发生了变化，完全按照教程会发生很多意想不到的错误，所以<strong>一定要先看官方文档</strong>，再按照教程的思路操作，其他的教程也是类似，更何况大多数官方文档都写的蛮直接友好的。</p>
<p>在搭建过程中出现问题也可以在其github页面中的issue查看有没有类似问题，大多数能解决而且效果比较好，相对于在搜索引擎上找解决办法更高效。我会在最后列出我碰到的一些问题。</p>
<p>本人是在<strong>ubuntu14.04LTS系统</strong>上搭建的，MacOS以及Win上我并没有试过，Win我不敢说，不过MacOS上大体相同。具体见对应的官方文档。</p>
<h1 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h1><p><a href="https://hexo.io/docs/" target="_blank" rel="external">HEXO的官方文档</a><br>按照这个安装肯定不会出错，不过我还是稍微翻译一下。</p>
<h2 id="安装hexo的依赖"><a href="#安装hexo的依赖" class="headerlink" title="安装hexo的依赖"></a>安装hexo的依赖</h2><p>在安装HEXO之前，首先要安装下面两个：</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>如果已经安装过了，可以直接进入最后安装HEXO那一步，否则按照下面继续。</p>
<blockquote>
<p>对于苹果用户而言首先要在应用商店里安装Xcode，然后再打开Xcode，前往<strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong>去安装<strong>command line tools</strong>(其实很多东西需要这个，早安了早解脱)。</p>
</blockquote>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><a href="http://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="external">Git安装官方文档</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="external">比较好的git教程</a><br>如果你使用的也是Ubuntu，那么安装Git非常方便，只要</p>
<blockquote>
<p>$ sudo apt-get install git</p>
</blockquote>
<p>万事大吉。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js其实我也不清楚，大家可以同理。<br>最好的办法是用<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>安装Node.js.<br>先安装nvm<br>cURL:</p>
<blockquote>
<p>$ curl <a href="http://raw.github.com/creationix/nvm/master/install.sh" target="_blank" rel="external">http://raw.github.com/creationix/nvm/master/install.sh</a> | sh</p>
</blockquote>
<p>Wget:</p>
<blockquote>
<p>$ wget -qO- <a href="https://raw.github.com/creationix/nvm/master/install.sh" target="_blank" rel="external">https://raw.github.com/creationix/nvm/master/install.sh</a> | sh</p>
</blockquote>
<p>nvm安装好了之后再安装Node.js</p>
<blockquote>
<p>$ nvm install 0.12</p>
</blockquote>
<h2 id="安装HEXO-1"><a href="#安装HEXO-1" class="headerlink" title="安装HEXO"></a>安装HEXO</h2><p>上面的依赖都安装好了的话安装HEXO就很快了,只需要</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm的官方文档(readme.md)</a><br><a href="https://nodejs.org/documentation/" target="_blank" rel="external">node.js的官方文档</a></p>
<h1 id="Github-Page的配置"><a href="#Github-Page的配置" class="headerlink" title="Github Page的配置"></a>Github Page的配置</h1><p>HEXO准备好之后就要把Github Page这部分搞定了。</p>
<h2 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a>注册Github</h2><p>Github主页: <a href="github.com">github.com</a><br>注册就不多说了，大家都会。</p>
<h2 id="配置SSH-keys"><a href="#配置SSH-keys" class="headerlink" title="配置SSH keys"></a>配置SSH keys</h2><p>为了让Github与本地的Git有安全稳定的连接，需要先配置SSHkeys。<br><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">SSH配置官方文档</a><br>或者参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="external">寥雪峰的Git教程</a>，里面介绍的比较详细。<br>这一部分比较琐碎，而且相关的文档很详细而且没什么变化，大家可以自己解决。</p>
<h2 id="建立GitHub-Pages"><a href="#建立GitHub-Pages" class="headerlink" title="建立GitHub Pages"></a>建立GitHub Pages</h2><p><a href="https://help.github.com/categories/github-pages-basics/" target="_blank" rel="external">Github Pages的官方文档</a><br>Github Pages分两种，一种是个人的，建立如同username.github.io这样的个人页面或者组织页面，另一种是项目页面。我们用的是第一种页面。<br>首先我们要建立一个Github仓库(respository)，登录github之后在页面的右上角有个加号，点击之后选择create new respository就可以建立一个新的个人仓库了。<br><img src="http://7xl294.com1.z0.glb.clouddn.com/2015-08-13%2013%3A33%3A47屏幕截图.png" alt=""><br>在Repository name中填写项目名称，形式是username.github.io。</p>
<blockquote>
<p>注意！username一定要和Owner里的名字相同，比如我只能写Arnold-Hu.github.io，githab不支持其他的写法作为github pages.<br>Description中写有关项目的描述，看着写，可选项。</p>
</blockquote>
<p>到这里，github pages也搞定了，可以开始进行搭建了。</p>
<h1 id="搭建个人主页"><a href="#搭建个人主页" class="headerlink" title="搭建个人主页"></a>搭建个人主页</h1><h2 id="HEXO指令"><a href="#HEXO指令" class="headerlink" title="HEXO指令"></a>HEXO指令</h2><p>HEXO非常的简单，只有下面几个重要的指令</p>
<blockquote>
<p>$ hexo init<br>初始化hexo项目 </p>
<p>$ hexo new<br>新建一篇文章</p>
<p>$ hexo generator<br>生成页面文件(因为hexo只是一个框架，每次有所修改必须要通过这个命令生成页面文件才行)</p>
<p>$ hexo clean<br>清除页面文件</p>
<p>$ hexo deploy<br>上传页面文件</p>
<p>$ hexo server<br>生成一个本地服务器</p>
</blockquote>
<p>详细用法见<a href="https://hexo.io/docs/commands.html" target="_blank" rel="external">官方文档指令部分</a></p>
<h2 id="部署HEXO"><a href="#部署HEXO" class="headerlink" title="部署HEXO"></a>部署HEXO</h2><p>在你的电脑中创建一个空文件夹，可以起名为“HEXO”或者“personal-web”等随你喜欢，但是之后我以“HEXO”代之这个文件夹。进入这个文件夹，然后输入</p>
<blockquote>
<p>$ git init</p>
<p>$ hexo init</p>
</blockquote>
<p>HEXO会初始化这个文件夹，并在里面部署好搭建网站需要的文件。<br>HEXO已经有一个缺省的页面，你可以先看看效果<br>相对于老版本的HEXO，新版本要先启动本地服务器的功能</p>
<blockquote>
<p>$ npm install hexo-server –save</p>
</blockquote>
<p>然后再生成页面文件并且生成本地服务器</p>
<blockquote>
<p>$ hexo generator</p>
<p>$ hexo server</p>
</blockquote>
<p>然后打开浏览器，在地址栏输入localhost:4000就可以看到一个自带的页面了</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>HEXO有很多的主题，选一个你喜欢的用就可以<br>先挑选一个主题：<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="external">zhihu:有那些好看的hexo主题？</a><br>然后根据相应主题的readme进行操作，我用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia的主题</a>,那么我就以此位例子简单介绍一下。<br>首先进入HEXO文件夹，然后</p>
<blockquote>
<p>$ git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="external">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p>
</blockquote>
<p>然后修改HEXO文件夹的<strong>_config.yml</strong>，把<strong>theme: landscape</strong>改成<strong>theme: yilia</strong><br>接着进行更新</p>
<blockquote>
<p>$ cd themes/yilia</p>
<p>$ git pull</p>
</blockquote>
<p>有关yilia的配置(HEXO/themes/yilia/_config.yml)见yilia的官方文档，在issues里面有很多人提出了对yilia的疑问，大部分问题在里面可以得到解决，如果无法解决再上网查或者直接提交issue问开发者本人。在后文中我汇介绍一些比较常用的插件配置和注意事项。<br>完成之后我们可以在本地服务器看看效果</p>
<blockquote>
<p>$ hexo clean</p>
<p>$ hexo generator</p>
<p>$ hexo server</p>
</blockquote>
<p>然后去localhost:4000查看。</p>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>首先我们要先配置好HEXO文件夹（根目录）中的<strong>_config.yml</strong>文件。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">   <span class="attribute">type</span>: git</span><br><span class="line">   <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/username/username.github.io.git</span></span><br><span class="line">   <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>在新的HEXO中，type改成了git而不是原来的github，里面的repository就是你在前面建立的那个github仓库，把username改成你的名字就可以了。现在就可以把生成的页面文件上传到github上了。</p>
<blockquote>
<p>$ hexo clean</p>
<p>$ hexo generator</p>
<p>$ hexo deploy</p>
</blockquote>
<p>完成之后可以在地址栏输入username.github.io，就可以看到你的自己的个人网站了。</p>
<h1 id="绑定独立域名"><a href="#绑定独立域名" class="headerlink" title="绑定独立域名"></a>绑定独立域名</h1><p>你可能觉得这个网站虽然看起来很不错，但是也许你会觉得这个域名比较low，像我这样的有逼格的人应该用一个有逼格的域名。那么你就需要一个独立域名了。</p>
<h2 id="买买买！"><a href="#买买买！" class="headerlink" title="买买买！"></a>买买买！</h2><p>推荐在godaddy上买域名，因为是国外的域名提供商，不像中国的域名提供商一样需要备案，方便快捷，而且现在支持支付宝，非常方便。<br>只要先查找好你要的域名，然后买买买就行了，我觉得没什么问题，如果实在感觉这个也搞不定，那么可以参考一下这篇文章，在我文章的时候这个教程还是合适的。<br><a href="http://www.admin5.com/article/20131014/527495.shtml" target="_blank" rel="external">在godaddy上买域名的详细步骤</a></p>
<h2 id="设置GitHub-Pages"><a href="#设置GitHub-Pages" class="headerlink" title="设置GitHub Pages"></a>设置GitHub Pages</h2><p>进入HEXO/source目录，在里面新建一个名为CNAME的文件，里面只需要填写一行，就是你的域名，比如我的CNAME文件中只写了一行 migdal-bavel.in<br>然后提交改动</p>
<blockquote>
<p>$ hexo generator</p>
<p>$ hexo deploy</p>
<p>注意:之后操作几乎之需要这两个命令，一个生成页面文件，一个提交给github</p>
</blockquote>
<h2 id="设置DNS"><a href="#设置DNS" class="headerlink" title="设置DNS"></a>设置DNS</h2><p>推荐使用DNSpod，稳定，在中国，效果好，快，免费。<br>先注册DNSpod，然后添加域名，把你的买来的域名输入进之后按下图进行添加记录<br><img src="http://7xl294.com1.z0.glb.clouddn.com/dns.png" alt=""><br>其中A的两条记录是指向github pages的服务器，我写文章的时候ip地址是这两个，但他可能会发生更改，一旦发现你博客上不去了，就可以取<a href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/" target="_blank" rel="external">这里</a>看看github pages的ip地址有没有换过。<br>然后www那个是你在github注册的仓库，照着我的格式写就行了，仓库换成你的。</p>
<h2 id="去godaddy修改DNS地址"><a href="#去godaddy修改DNS地址" class="headerlink" title="去godaddy修改DNS地址"></a>去godaddy修改DNS地址</h2><p>这一部分直接看<a href="https://support.dnspod.cn/Kb/showarticle/tsid/42/" target="_blank" rel="external">DNSpod提供的帮助</a><br>改完DNS之后要等一段时间让全球的DNS服务器刷新。</p>
<p>到这里，博客就搭建完了。</p>
<h1 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h1><h2 id="填写网站信息"><a href="#填写网站信息" class="headerlink" title="填写网站信息"></a>填写网站信息</h2><p>搭建完了博客之后那么就需要添加内容了，首先我们就要对HEXO文件夹下的<strong>_config.yml</strong>进行设置，只要把头部的内容填写一下就行，下面给出我的文件内容<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/Arnold-Hu/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> 巴别塔</span><br><span class="line"><span class="attr">subtitle:</span> 每天搭块砖～ 每天向上爬～</span><br><span class="line"><span class="attr">description:</span> 学习 感悟 精炼 内化</span><br><span class="line"><span class="attr">author:</span> Arnold-Hu</span><br><span class="line"><span class="attr">language:</span> zh-CN</span><br><span class="line"><span class="attr">timezone:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/&gt; &gt; child/'</span></span><br><span class="line"><span class="attr">url:</span> http://migdal-bavel.in</span><br><span class="line"><span class="attr">root:</span> /</span><br><span class="line"><span class="attr">permalink:</span> :year/:month/:day/:title/</span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure></p>
<p>详细的见<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">官方文档的设置部分</a></p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>建立博客干什么呢，当然是写文章拉～<br>在HEXO框架中写文章非常简单，只需要</p>
<blockquote>
<p>$ hexo n “文章标题”</p>
</blockquote>
<p>就行了，文章标题是你文章的标题，不要忘记双引号，不然会对你标题里的空格和一些特殊符号错误的识别。<br>通过这个指令会在 HEXO/source/_post中生成一个<strong>文章标题.md</strong>文件，你可以打开这个文件写文章或者以后想改文章也可以来这里改，不过记得要generator并且deploy.<br>自动生成的文章都有一个头，类似于这样<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> 利用github page以及hexo模板建立个人独立博客</span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-08</span><span class="bullet">-13</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">17</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p>基本上不用改，只要添加几个tags就行了。<br>tips：你写出的文章会全部显示在主页上，如果不想全部显示，只显示标题和一部分内容的话，可以在那一部分内容下面插入一行代码<br> <code>&lt;!--more--&gt;</code></p>
<p>这样就可以不在首页显示后面的内容。<br>写文章一般采用markdown语法，非常简单，而且写出来很好看很方便，5分钟学会。<br><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="external">新手markdown指南</a></p>
<h2 id="增加多说评论"><a href="#增加多说评论" class="headerlink" title="增加多说评论"></a>增加多说评论</h2><p>yilia作为一个华人开发的主题对多说的支持非常友好。<br>首先在多说先注册一个账户<br><img src="http://7xl294.com1.z0.glb.clouddn.com/多说.png" alt=""><br>如图，这是我的相应信息.<br>只需要把 HEXO/theme/yilia/_config.yml中的duoshuo:设置为<br><code>duoshuo: shortname</code></p>
<p>其中的shortname是图片中域名项除去.duoshuo.com的那部分，比如说我的就是migdal-bavel<br>然后就ok了。</p>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>markdown语法中图片是通过链接使用的，可以把图片放在本地文件中，也可以把图片放在网上。放在网上的话，推荐使用<a href="http://www.qiniu.com/" target="_blank" rel="external">七牛</a>，非常的快而且方便。</p>
<h2 id="404界面"><a href="#404界面" class="headerlink" title="404界面"></a>404界面</h2><p><a href="https://help.github.com/articles/custom-404-pages/" target="_blank" rel="external">github上对404界面的指引</a><br>当然，如果你想作一个比较简单的404界面，直接在HEXO/source下新建一个404.md就行了。<br>比如<a href="http://migdal-bavel.in/nothing" target="_blank" rel="external">我的404界面</a><br><strong>注意：在HEXO中每次用deploy上传都会覆盖掉原来在github上的文件，所以当你想在框架之外额外加入页面的话，必须把页面放在HEXO/source文件夹中，不然都会被覆盖掉。</strong><br><strong>并且，这里面的所有文件都会都会被hexo框架解析并且更改，如果不想让页面采用hexo的格式，那么就必须在文件最开始加入</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p><strong>以表示不采用hexo框架的模板。</strong><br>之后加入自己的页面或者readme.md文件或者加入谷歌百度的验证页面都要注意这些。</p>
<h2 id="加载sitemap和rss"><a href="#加载sitemap和rss" class="headerlink" title="加载sitemap和rss"></a>加载sitemap和rss</h2><p><strong>首先要回到根目录HEXO/</strong><br>然后安装</p>
<blockquote>
<p>$ npm install hexo-generator-feed</p>
<p>$ npm install hexo-generator-sitemap</p>
</blockquote>
<p>再编辑HEXO/_config.yml，在其中的plugins里加入下面的代码<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">-<span class="ruby"> hexo-generator-feed</span><br><span class="line"></span>-<span class="ruby"> hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure></p>
<h2 id="yilia的一些格式问题"><a href="#yilia的一些格式问题" class="headerlink" title="yilia的一些格式问题"></a>yilia的一些格式问题</h2><p>yilia中的subnav如下类似设置，<strong>不要用短域名</strong><br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">subnav:</span></span><br><span class="line"><span class="symbol">  github:</span> <span class="string">"https://github.com/Arnold-Hu"</span></span><br><span class="line"> <span class="meta">#weibo: <span class="string">"http://weibo.com/2112831602"</span></span></span><br><span class="line"><span class="symbol">  rss:</span> <span class="string">"atom.xml"</span></span><br><span class="line"><span class="symbol">  zhihu:</span> <span class="string">"http://www.zhihu.com/people/hu-cheng-cheng-66"</span></span><br><span class="line">  <span class="meta">#douban: <span class="string">"#"</span></span></span><br><span class="line"><span class="symbol">  mail:</span> <span class="string">"mailto:hbc0204@foxmail.com"</span></span><br><span class="line">  <span class="meta">#facebook: <span class="string">"#"</span></span></span><br><span class="line">  <span class="meta">#google: <span class="string">"#"</span></span></span><br><span class="line">  <span class="meta">#twitter: <span class="string">"#"</span></span></span><br><span class="line">  <span class="meta">#linkedin: <span class="string">"#"</span></span></span><br></pre></td></tr></table></figure></p>
<p>  前面加了#号的项在主页左下角不会出现，并且把rss设置为rss:”atom.xml”就行了。</p>
<h1 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>http://migdal-bavel.in.com/2015/08/22/Welcome/</url>
      <content type="html"><![CDATA[<p>因为感觉独立的博客很有逼格，以后也想在学习的过程中有记录一点东西的地方，所以特地搭建了一个个人博客。因为不懂前端技术，没办法自己写所以就利用框架先做一个，以后有水平了再迁移。<br>博客的名字是希伯来语里的巴别塔（为了装逼什么都干得出来）。希望能如同巴别塔一样借助全人类的知识慢慢的成长提高。<br>各位如果感兴趣的话可以收藏页面或者订阅rss，我会不定期的更新一些内容。</p>
]]></content>
    </entry>
    
  
  
</search>
