{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/leetcode contest 189/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"d47b68ac-c265-5fa0-8956-6e40bb4e2cff","excerpt":"1450. Number of Students Doing Homework at a Given Time Difficulty:Easy 没什么好说的，就是遍历 1451. Rearrange Words in a Sentence Medium 这个也没有什么算法的问题…","html":"<h2><a href=\"https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/\">1450. Number of Students Doing Homework at a Given Time</a></h2>\n<p>Difficulty:Easy</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given two integer arrays startTime and endTime and given an integer queryTime.\n\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\n\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n\n \n\nExample 1:\n\nInput: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\nOutput: 1\nExplanation: We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn&#39;t doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn&#39;t doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\nExample 2:\n\nInput: startTime = [4], endTime = [4], queryTime = 4\nOutput: 1\nExplanation: The only student was doing their homework at the queryTime.\nExample 3:\n\nInput: startTime = [4], endTime = [4], queryTime = 5\nOutput: 0\nExample 4:\n\nInput: startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\nOutput: 0\nExample 5:\n\nInput: startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\nOutput: 5\n \n\nConstraints:\n\nstartTime.length == endTime.length\n1 &lt;= startTime.length &lt;= 100\n1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000\n1 &lt;= queryTime &lt;= 1000</code></pre></div>\n<p>没什么好说的，就是遍历</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int cnt = 0;\n        for (int i = 0; i &lt; startTime.length; i++) {\n            if (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/rearrange-words-in-a-sentence/\">1451. Rearrange Words in a Sentence</a></h2>\n<p>Medium</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given a sentence text (A sentence is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\nYour task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\n\nReturn the new text following the format shown above.\n\n \n\nExample 1:\n\nInput: text = &quot;Leetcode is cool&quot;\nOutput: &quot;Is cool leetcode&quot;\nExplanation: There are 3 words, &quot;Leetcode&quot; of length 8, &quot;is&quot; of length 2 and &quot;cool&quot; of length 4.\nOutput is ordered by length and the new first word starts with capital letter.\nExample 2:\n\nInput: text = &quot;Keep calm and code on&quot;\nOutput: &quot;On and keep calm code&quot;\nExplanation: Output is ordered as follows:\n&quot;On&quot; 2 letters.\n&quot;and&quot; 3 letters.\n&quot;keep&quot; 4 letters in case of tie order by position in original text.\n&quot;calm&quot; 4 letters.\n&quot;code&quot; 4 letters.\nExample 3:\n\nInput: text = &quot;To be or not to be&quot;\nOutput: &quot;To be or to be not&quot;\n \n\nConstraints:\n\ntext begins with a capital letter and then contains lowercase letters and single space between words.\n1 &lt;= text.length &lt;= 10^5</code></pre></div>\n<p>这个也没有什么算法的问题，就是重新排序。注意一下第一位就可以，用map来辅助或者一个记录位置的map来辅助sort也可以。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public String arrangeWords(String text) {\n        String[] words = text.split(&quot; &quot;);\n        Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();\n        for (String word : words) {\n            map.putIfAbsent(word.length(), new ArrayList&lt;&gt;());\n            map.get(word.length()).add(word.toLowerCase());\n        }\n        List&lt;Integer&gt; lens = new ArrayList&lt;&gt;(map.keySet());\n        lens.sort(Comparator.comparingInt(x-&gt;x));\n        List&lt;String&gt; ret = new ArrayList&lt;&gt;();\n        for (int len : lens) {\n            ret.addAll(map.get(len));\n        }\n        String first = ret.get(0);\n        char newFirst = (char) (first.charAt(0) + (&#39;A&#39; - &#39;a&#39;));\n        StringBuffer newS = new StringBuffer(first);\n        newS.setCharAt(0, newFirst);\n        ret.set(0, newS.toString());\n        return String.join(&quot; &quot;, ret);\n    }\n}</code></pre></div>\n<h2>【1452. People Whose List of Favorite Companies Is Not a Subset of Another List](<a href=\"https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/\">https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</a>)</h2>\n<p>Medium</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).\n\nReturn the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.\n\n \n\nExample 1:\n\nInput: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]\nOutput: [0,1,4] \nExplanation: \nPerson with index=2 has favoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] corresponding to the person with index 0. \nPerson with index=3 has favoriteCompanies[3]=[&quot;google&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] and favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;]. \nOther lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].\nExample 2:\n\nInput: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]\nOutput: [0,1] \nExplanation: In this case favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;], therefore, the answer is [0,1].\nExample 3:\n\nInput: favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]\nOutput: [0,1,2,3]\n \n\nConstraints:\n\n1 &lt;= favoriteCompanies.length &lt;= 100\n1 &lt;= favoriteCompanies[i].length &lt;= 500\n1 &lt;= favoriteCompanies[i][j].length &lt;= 20\nAll strings in favoriteCompanies[i] are distinct.\nAll lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j].\nAll strings consist of lowercase English letters only.</code></pre></div>\n<p>一开始我还想着用什么算法能跳过暴力求解，后面想了十分钟想不到就直接暴力解了。发现也可以accept，唯一一个优化就是如果确定了一个人喜欢的公司是另外一个人的子集，那么这个人就不需要被比较了。暴力解法如下，就是直接一次次遍历。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n     public List&lt;Integer&gt; peopleIndexes(List&lt;List&lt;String&gt;&gt; favoriteCompanies) {\n        List&lt;Integer&gt; indexs = new ArrayList&lt;&gt;();\n        List&lt;Set&lt;String&gt;&gt; r = new ArrayList&lt;&gt;();\n        for (List&lt;String&gt; comps : favoriteCompanies) {\n            r.add(new HashSet&lt;&gt;(comps));\n        }\n        Set&lt;Integer&gt; shouldPass = new HashSet&lt;&gt;();\n\n        for (int i = 0; i &lt; favoriteCompanies.size(); i++) {\n            for (int j = 0; j &lt; favoriteCompanies.size(); j++) {\n                if (j == i || shouldPass.contains(j)) {\n                    continue;\n                }\n                if (isSub(r.get(i), r.get(j))) {\n                    shouldPass.add(i);\n                    break;\n                }\n            }\n            if (!shouldPass.contains(i)) {\n                indexs.add(i);\n            }   \n        }\n        return indexs;\n    }\n    \n    private boolean isSub(Set&lt;String&gt; l1, Set&lt;String&gt; l2) {\n        for (String comp : l1) {\n            if (!l2.contains(comp)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/\">1453. Maximum Number of Darts Inside of a Circular Dartboard</a></h2>\n<p>Hard</p>\n<p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane. </p>\n<p>Return the maximum number of points that are within or lie on any circular dartboard of radius r.</p>\n<p>Example 1:</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\nOutput: 4\nExplanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.</code></pre></div>\n<p>Example 2:</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\nOutput: 5\nExplanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).</code></pre></div>\n<p>Example 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1\nOutput: 1</code></pre></div>\n<p>Example 4:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2\nOutput: 4</code></pre></div>\n<p>Constraints:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 &lt;= points.length &lt;= 100\npoints[i].length == 2\n-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4\n1 &lt;= r &lt;= 5000</code></pre></div>\n<p>这个题目其实挺有意思的，一开始是按题目的思路想着怎么用圆去覆盖他们。但是因为圆心的位置是float的，不可能全部遍历，所以只能换一种思路。后面想到了，最小覆盖圆的方法。y原理是这样的，如果有一个半径为r的圆能最多覆盖n个点，那么必然存在一个子圆，同样覆盖n个相同的点，且有至少两个点在子圆的边界上。两个点可以用直径确定一个圆，而三个点可以唯一确定一个圆。那么整个计算的过程就是这样的，遍历两个点和三个点的组合，确定其对应的圆，如果半径比r小，那么计算有多少个其他点在圆中，如此得到那个能包含最多点的子圆。然后其中注意一下double的计算判断是否包含要留一些buffer。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int numPoints(int[][] points, int r) {\n        int maxCount = 1;\n\n        for (int i = 0; i &lt; points.length; i++) {\n            for (int j = i + 1; j &lt; points.length; j++) {\n                List&lt;Double&gt; twoPointCir = decideCircle(points[i], points[j]);\n                int cc = 2;\n                if (twoPointCir.get(2) &gt; r * 1.0001) {\n                    continue;\n                }\n                for (int m = 0; m &lt; points.length; m++) {\n                    if (m == i || m == j) {\n                        continue;\n                    }\n                    if (isIn(twoPointCir, points[m])){\n                        cc++;\n                    }\n                }\n                maxCount = Math.max(maxCount, cc);\n                \n                \n                for (int k = j + 1; k &lt; points.length; k++) {\n                    List&lt;Double&gt; cir = decideCircle(points[i], points[j], points[k]);\n                    if (cir == null) {\n                        continue;\n                    }\n                    if (cir.get(2) &gt; r) {\n                        continue;\n                    }\n                    int cnt = 3;\n                    for (int m = 0; m &lt; points.length; m++) {\n                        if (m == i || m == j || m == k) {\n                            continue;\n                        }\n                        if (isIn(cir, points[m])){\n                            cnt++;\n                        }\n                    }\n                    maxCount = Math.max(maxCount, cnt);\n                }\n            }\n        }\n        return maxCount;\n    }\n    private double distance(int[] d1, int[] d2) {\n        double x = d1[0] - d2[0];\n        double y = d1[1] - d2[1];\n        return Math.sqrt(x * x + y * y);\n    }\n    private List&lt;Double&gt; decideCircle(int[] d1, int[] d2) {\n        double dis = distance(d1, d2);\n        double x0 = (d1[0] + d2[0]) / 2.0;\n        double y0 = (d1[1] + d2[1]) / 2.0;\n        return Arrays.asList(x0, y0, dis / 2.0);\n    }\n    \n    // x0, y0, r\n    private List&lt;Double&gt; decideCircle(int[] d1, int[] d2, int[] d3) {\n        double a = d1[0] - d2[0];\n        double b = d1[1] - d2[1];\n        double c = d1[0] - d3[0];\n        double d = d1[1] - d3[1];\n        double a1 = ((d1[0] * d1[0] - d2[0] * d2[0]) + (d1[1] * d1[1] - d2[1] * d2[1])) / 2.0;\n        double a2 = ((d1[0] * d1[0] - d3[0] * d3[0]) + (d1[1] * d1[1] - d3[1] * d3[1])) / 2.0;\n        double theta = b * c - a * d;\n        if (Math.abs(theta) &lt; 0.00001) {\n            return null;\n        }\n        double x0 = (b * a2 - d * a1) / theta;\n        double y0 = (c * a1 - a * a2) / theta;\n        double r = Math.sqrt((d1[0] - x0) * (d1[0] - x0) + (d1[1] - y0) * (d1[1] - y0));\n        return Arrays.asList(x0, y0, r);\n    }\n\n    private boolean isIn(List&lt;Double&gt; circle, int[] dot) {\n        double x0 = circle.get(0);\n        double y0 = circle.get(1);\n        double r = circle.get(2);\n        double disSquare = (x0 - dot[0]) * (x0 - dot[0]) + (y0 - dot[1]) * (y0 - dot[1]);\n        return disSquare &lt; r * r * 1.0001;\n    }\n}</code></pre></div>","frontmatter":{"title":"leetcode contest 189","date":"May 16, 2020","tags":["leetcode","contest"]}}},"pageContext":{"slug":"/leetcode contest 189/","previous":null,"next":{"fields":{"slug":"/leetcode contest 188/"},"frontmatter":{"title":"leetcode contest 188"}}}}}