{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/gatsby建站详细教程及避坑攻略/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"6b85dc2c-cfe7-5739-a9cd-9fb723189e7a","excerpt":"这篇文章算是对这段时间折腾的一个东西的技术总结，在之前文章博客迁移中，我已经总结了项目的背景，技术选型等形而上的内容，这篇文章主要是技术总结，并且帮助大家能从我的视角了解gatsby，并且快速的上手实践。 Gatsby是什么，为什么要用Gatsby Gatsby实际上是是一个r…","html":"<p>这篇文章算是对这段时间折腾的一个东西的技术总结，在之前文章<a href=\"http://hubingcheng.com/blog/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB\">博客迁移</a>中，我已经总结了项目的背景，技术选型等形而上的内容，这篇文章主要是技术总结，并且帮助大家能从我的视角了解gatsby，并且快速的上手实践。</p>\n<h2>Gatsby是什么，为什么要用Gatsby</h2>\n<p>Gatsby实际上是是一个react的静态化框架。React本身实际上能完成所有gatsby的功能。但是有一个问题就是，react是一个单页应用（SPA - single page application）,本身实际上是在前端动态的生成页面。这样就会有两个问题，一个是首屏加载时间很长。第二个因为页面是动态生成，所以搜索引擎不知道每个页面的内容，对SEO很不友好。对于这些问题，react的服务端渲染框架（SSR - server side render）应运而生。而SSR本身也有很多不同的实现方案，有些是直接搭一个渲染服务器多一个中间层，而有一些就比较极端，比如gatsby，直接在编译的时候就把整个网站静态化。这样上面的问题就迎刃而解了。</p>\n<h2>gatsby如何工作</h2>\n<p>react吸引人的特点之一就是她的动态特性，如果在编译的时候就把整个网站静态化，那么这些动态的特性该如何保证呢？Gatsby给出的方案就是程序化生成页面。具体的说，gatsby的页面生成有两种方式，一个是直接把react组件写在<code class=\"language-text\">/src/pages</code>目录下，比如<code class=\"language-text\">/src/pages/tags.js</code>对应的页面就是<code class=\"language-text\">/tags</code>。第二种就是通过gatsby的api动态的构建页面了，官方的说明文档在<a href=\"https://www.gatsbyjs.cn/tutorial/part-seven/\">这里</a>.简而言之就是</p>\n<ol>\n<li>创建页面模板</li>\n<li>通过graphQL获取用于生成页面的数据</li>\n<li>在gatsby-node.js中通过<code class=\"language-text\">createPage</code>和<code class=\"language-text\">onCreateNode</code>两个API生成页面</li>\n</ol>\n<h2>实战</h2>\n<p>实战部分手把手教你创建一个和我一样的博客</p>\n<h2>创建项目</h2>\n<p>首先你需要安装gatsby及其依赖</p>\n<p>然后通过博客模板创建项目</p>\n<p><code class=\"language-text\">$ gatsby new my-blog-starter https://github.com/gatsbyjs/gatsby-starter-blog</code></p>\n<p>然后</p>\n<p><code class=\"language-text\">$ cd my-blog-stater &amp;&amp; npm start</code>\n就可以打开浏览器输入<code class=\"language-text\">localhost:8000</code>看到主页了</p>\n<p><img src=\"https://bates-hu-blog-1256120017.cos.ap-shanghai.myqcloud.com/undefined20200227175924.png\" alt=\"20200227175924.png\"></p>\n<h2>增加tags相关页面</h2>\n<p>如果你想像我的<a href=\"http://hubingcheng.com\">主页</a>一样拥有<a href=\"http://hubingcheng.com/tags\">tags页面</a>的话。可以通过以下操作</p>\n<h4>增加tag标签</h4>\n<p>要增加tags界面，首先得有tags。要做的很简单，就是在你的markdown文章中增加tags标签如图\n<img src=\"https://bates-hu-blog-1256120017.cos.ap-shanghai.myqcloud.com/undefined20200227191105.png\" alt=\"20200227191105.png\">\n<img src=\"https://bates-hu-blog-1256120017.cos.ap-shanghai.myqcloud.com/undefined20200227191128.png\" alt=\"20200227191128.png\">\n文章在<code class=\"language-text\">/content/blog/{title}</code>这个路径中</p>\n<h4>生成网页</h4>\n<p>tags相关的页面有两个，一个是<code class=\"language-text\">/tags</code>,另一个是<code class=\"language-text\">/tag/{tag}</code>，前一个用于展示所有的tag，其中点击任意一个tag就是跳转到对应tag的文章列表，也就是后面的页面。</p>\n<p>因为<code class=\"language-text\">/tags</code>依赖<code class=\"language-text\">/tag/{tag}</code>，所以我们首先我们生成<code class=\"language-text\">/tag/{tag}</code>,根据前面介绍gatsby如何工作</p>\n<p>首先我们需要创建一个页面模板<code class=\"language-text\">/src/templates/tag-posts.js</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;\nimport { graphql, Link } from &quot;gatsby&quot;\n\nconst TagPost = ({data, pageContext}) =&gt; {\n  const posts = data.allMarkdownRemark.edges\n\n  return (\n    \n      &lt;div&gt;\n      &lt;h1&gt;Posts for tag: {pageContext.targetTag}&lt;/h1&gt;\n      &lt;p&gt;{posts.length + &quot; posts&quot;}&lt;/p&gt;\n      &lt;hr /&gt;\n      &lt;ul&gt;\n      {posts.map(({ node }) =&gt; {\n        const title = node.frontmatter.title || node.fields.slug\n        return (\n          &lt;li&gt;&lt;Link to={node.fields.slug}&gt;{title}&lt;/Link&gt;&lt;/li&gt; \n        )\n      })}\n      &lt;/ul&gt;\n      &lt;/div&gt;\n\n      \n  )\n}\n\nexport default TagPost\n\nexport const pageQuery = graphql`\n  query($targetTag: String!) {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    allMarkdownRemark(filter: {frontmatter: {tags: {eq: $targetTag}}}, sort: {fields: frontmatter___date, order: DESC}) {\n      edges {\n        node {\n          excerpt(truncate: true)\n          fields {\n            slug\n          }\n          frontmatter {\n            date(formatString: &quot;MMMM DD, YYYY&quot;)\n            title\n            tags\n          }\n        }\n      }\n    }\n  }\n`</code></pre></div>\n<p>然后按照第二部，在<code class=\"language-text\">gatsby-node.js</code>中生成页面，添加如下代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">exports.createPages = async ({ graphql, actions }) =&gt; {\n  const { createPage } = actions\n\n  /*\n  此处省略生成blog-post的代码\n  */\n\n  // start generate tag posts\n  const tagPost = path.resolve(`./src/templates/tag-posts.js`)\n  const tagPostResult = await graphql(\n    `\n    {\n      allMarkdownRemark {\n        nodes {\n          frontmatter {\n            tags\n          }\n        }\n      }\n    }\n    `\n  )\n\n  if (tagPostResult.errors) {\n    throw tagPostResult.errors\n  }\n\n  const nodes = tagPostResult.data.allMarkdownRemark.nodes\n\n  //extract distict tags of all posts\n  var tagSet = new Set()\n  nodes.forEach(node =&gt; node.frontmatter.tags.forEach(tag =&gt; tagSet.add(tag)))\n\n  // gen page for each tag\n  tagSet.forEach( tag =&gt; createPage({\n    path: &quot;tag/&quot; + tag,\n    component: tagPost,\n    context: {\n      targetTag : tag\n    },\n  }))\n\n}</code></pre></div>\n<p>之后你重新<code class=\"language-text\">npm start</code>,然后输入网址<code class=\"language-text\">http://localhost:8000/tag/tag2</code>，你就能看到下面的页面\n<img src=\"https://bates-hu-blog-1256120017.cos.ap-shanghai.myqcloud.com/undefined20200227191308.png\" alt=\"20200227191308.png\"></p>\n<p>现在我们要生成<code class=\"language-text\">/tags</code>的页面，这个不是一个动态路径，所以我们在<code class=\"language-text\">/src/pages</code>添加一个js文件就可以了<code class=\"language-text\">/src/pages/tags.js</code>，里面的代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &quot;react&quot;\nimport { Link, graphql } from &quot;gatsby&quot;\n\n\nconst Tags = ({ data }) =&gt; {\n  const posts = data.allMarkdownRemark.edges\n  var tagMap = new Map()\n\n\n  for (const post of posts) {\n    for (const tag of post.node.frontmatter.tags) {\n      if (tagMap.has(tag)) {\n        tagMap.set(tag, tagMap.get(tag) + 1)\n      } else {\n        tagMap.set(tag, 1)\n      }\n    }\n  }\n  var tagPair = Array.from(tagMap)\n  tagPair.sort((left, right) =&gt; right[1] - left[1])\n\n  console.log(tagPair)\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;All Tags&lt;/h1&gt;\n      &lt;p&gt;Click the tag to read related articles&lt;/p&gt;\n      &lt;hr /&gt;\n      &lt;ul&gt;\n        {tagPair.map(([tag, count]) =&gt; {\n          return (\n                &lt;li&gt;&lt;Link to={&quot;tag/&quot; + tag} className=&quot;tag&quot;&gt;{tag + &quot; | &quot; + count + &quot; posts&quot;}&lt;/Link&gt;&lt;/li&gt;\n          )\n        })}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default Tags\n\nexport const pageQuery = graphql`\n  query {\n    allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC }) {\n      edges {\n        node {\n          frontmatter {\n            tags\n          }\n        }\n      }\n    }\n  }\n`</code></pre></div>\n<p>然后再浏览器输入<code class=\"language-text\">http://localhost:8000/tags</code>，就可以看到下面的页面\n<img src=\"https://bates-hu-blog-1256120017.cos.ap-shanghai.myqcloud.com/undefined20200227195057.png\" alt=\"20200227195057.png\"></p>\n<p>这两类页面就覆盖了两种页面的生成方式，其他的页面就靠大伙举一反三了</p>\n<h2>优化</h2>\n<h4>增加css效果</h4>\n<p>刚才生成的页面中，都是光秃秃的文字，为了页面更美观，需要加上css效果使其更美观，博客本身的css框架我并不是很喜欢，所以我换了一个我比较喜欢另一个轻便的css框架<a href=\"http://bulma.io\">BULMA</a></p>\n<p>这个框架的特点就是简单轻巧，只有css，没有js，不容易和其他的组件产生冲突。而且非常的易用。</p>\n<p>官方有介绍如何接入的<a href=\"https://www.gatsbyjs.cn/docs/bulma/#using-bulma\">文档</a></p>\n<p>具体如何使用，或者想直接抄作业可以直接看我的<a href=\"https://github.com/bates-hu/bates-hu.github.io/tree/source\">源码</a></p>\n<h4>组件化</h4>\n<p>组件就是很多页面需要公用的模块就会抽象成组件，这样会使代码变得优雅易懂。</p>\n<p>比如每个页面都要页眉页脚，这些就可以抽象出Layout组件。每个页面又要不同的元信息做SEO，这就抽象出了SEO组件。比如我觉得展示文章需要用统一的卡片样式，我自己就抽象出了PostCard组件。还有每个页面可能都需要的Comment组件。</p>\n<p>因为gatsby本身就是从react扩展出来的框架，自然也可以使用组件来优雅的开发界面。组件所在的路径是<code class=\"language-text\">/src/components/</code>。里面已经有了<code class=\"language-text\">Layout</code>和<code class=\"language-text\">SEO</code>等组件。相关的语法需要查阅一下react的文档。依葫芦画瓢写还是比较简单的。</p>\n<p>具体的怎么写可以直接看我的<a href=\"https://github.com/bates-hu/bates-hu.github.io/tree/source\">源码</a></p>\n<h4>第三方评论</h4>\n<p>之前我的hexo博客用的是国内的多说，但是多说已经不运营了。但是我又不想自己额外维护一个评论数据库。所以我调研了一圈，对比了一番发现几个可能可用的</p>\n<ul>\n<li>Disqus - 这个是世界上最大也是最成熟的，但是在中国被墙了。pass</li>\n<li>gitcomment - 这个是通过github issue来实现的，强制用github登录。对于非码农的评论者不友好，而且github在中国api的效率也存疑。pass</li>\n<li>levere(来必力) - 这个是韩国的一个第三方模块，对中国的本地化支持的很好，支持简单回复和包括微信在内的各种第三方账号登录。看他的客户也不像会倒的样子，所以就用他了。</li>\n</ul>\n<p>levere有个问题就是在移动端打开的时候无法微信登录，这个我咨询了他们的客服，他们回复这个就是这样，因为微信得扫码，所以无法移动端登录。无解。而且在集成的时候还碰到了一些坑，见下文。</p>\n<h4>托管</h4>\n<p>整个网页托管到了github page上，具体怎么托管，请翻阅<a href=\"https://www.gatsbyjs.cn/docs/how-gatsby-works-with-github-pages/\">文档</a></p>\n<h4>自动化</h4>\n<p>因为gatsby出色的架构，整个网站现在只需要增加markdown文章，其他的任何内容都不需要更改就会自动的构建并发布新网站。但是我简直懒到了家，为了实现hexo一样，只要hexo new就可以写新文章的便捷，我写了一个脚本<a href=\"https://github.com/bates-hu/bates-hu.github.io/blob/source/gen-new-post.js\">\\gen-new-post.js</a>，然后再<code class=\"language-text\">/package.json</code>的<code class=\"language-text\">script</code>中增加一条命令</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;new&quot;: &quot;node gen-new-post.js $*&quot;,</code></pre></div>\n<p>这样，我们就可以用<code class=\"language-text\">npm run new {newtitle}</code>自动生成markdown文件啦。</p>\n<h2>踩坑</h2>\n<h4>graphQL相关</h4>\n<p>你的每个md文件都要加上<code class=\"language-text\">tags:[]</code>, 不然graphQL读出来的话这个属性就是null而不会是空的array，那样的话<code class=\"language-text\">tags.foreach</code> 和 <code class=\"language-text\">tags.map()</code>就会报错。</p>\n<h4>Link 和 a，两种不同的跳转</h4>\n<p>官方介绍说<code class=\"language-text\">Link</code>是用来跳转到应用内的页面的，而<code class=\"language-text\">a</code>则是用来跳转到外链的。但是这样其实是有一个问题，一开始我的评论模块时通过<code class=\"language-text\">helmet</code>模块把第三方评论的脚本写到每个post的页面的header里面。第一次点击文章没有问题，但是从一篇文章通过点击下一篇文章的链接跳转的时候，评论模块就消失了。在网上查了一下，里面有一个解决方案是吧Link改成a。确实有效。但是我进一步探究了一下为什么。</p>\n<p>查了很多资料后我知道了原因，gatsby的Link实际上和react的Route类似，会做优化做预加载，加快跳转速度。通过Link跳转的话，其实用的是react特有的diff渲染，这种渲染只会渲染两个页面不同的部分。因为两篇post的header部分几乎完全相同，所以在渲染的时候评论模块的script是不会重新生成的，而评论模块时script脚本动态生成的，所以就消失了。</p>\n<p>使用a的话，会强制整个页面进行更新，这个自然是可行的，但是就没有了预加载的优势。页面的跳转就不会快如闪电，不够优雅。</p>\n<p>其实这个可以通过一个优雅的方式解决。就是react的<code class=\"language-text\">hook</code>。在Comment组件中增加一个hook - useEffect。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Comment = () =&gt; {\n    useEffect(() =&gt; {\n        var j, e = document.getElementsByTagName(&quot;script&quot;)[0];\n\n       if (typeof LivereTower === &#39;function&#39;) { return; }\n\n       j = document.createElement(&quot;script&quot;);\n       j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;;\n       j.async = true;\n\n       e.parentNode.insertBefore(j, e);\n    });\n  return (\n    &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;xxxxx&quot;&gt;\n    &lt;/div&gt;\n  )\n}</code></pre></div>\n<p><code class=\"language-text\">useEffect</code> 的作用是每次在组件加载和更新的时候，会调用一次这个方法。而comment组件又是嵌在tag-post中的，所以每次切换文章，tag-post肯定需要重新加载，所以comment也需要重新加载，而useEffect就会动态的插入一个script，这个新插入的script就会动态生成一个第三方评论框，问题解决。</p>","frontmatter":{"title":"gatsby建站详细教程及避坑攻略","date":"February 27, 2020","tags":["教程","react","gatsby"]}}},"pageContext":{"slug":"/gatsby建站详细教程及避坑攻略/","previous":null,"next":{"fields":{"slug":"/半年总结/"},"frontmatter":{"title":"半年总结"}}}}}