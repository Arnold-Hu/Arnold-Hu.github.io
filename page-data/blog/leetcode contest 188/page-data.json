{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/leetcode contest 188/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"b882755e-da2f-5d58-9035-41d02030f832","excerpt":"Build an Array With Stack Operations\nEasy 没什么难度，就是如果在target里就push，不在的话就push & pop 1442. Count Triplets That Can Form Two Arrays of Equal XO…","html":"<ol start=\"1441\">\n<li>Build an Array With Stack Operations\nEasy</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given an array target and an integer n. In each iteration, you will read a number from  list = {1,2,3..., n}.\n\nBuild the target array using the following operations:\n\nPush: Read a new element from the beginning list, and push it in the array.\nPop: delete the last element of the array.\nIf the target array is already built, stop reading more elements.\nYou are guaranteed that the target array is strictly increasing, only containing numbers between 1 to n inclusive.\n\nReturn the operations to build the target array.\n\nYou are guaranteed that the answer is unique.\n\n \n\nExample 1:\n\nInput: target = [1,3], n = 3\nOutput: [&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\nExplanation: \nRead number 1 and automatically push in the array -&gt; [1]\nRead number 2 and automatically push in the array then Pop it -&gt; [1]\nRead number 3 and automatically push in the array -&gt; [1,3]\nExample 2:\n\nInput: target = [1,2,3], n = 3\nOutput: [&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\nExample 3:\n\nInput: target = [1,2], n = 4\nOutput: [&quot;Push&quot;,&quot;Push&quot;]\nExplanation: You only need to read the first 2 numbers and stop.\nExample 4:\n\nInput: target = [2,3,4], n = 4\nOutput: [&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n \n\nConstraints:\n\n1 &lt;= target.length &lt;= 100\n1 &lt;= target[i] &lt;= 100\n1 &lt;= n &lt;= 100\ntarget is strictly increasing.</code></pre></div>\n<p>没什么难度，就是如果在target里就push，不在的话就push &#x26; pop</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public List&lt;String&gt; buildArray(int[] target, int n) {\n        List&lt;String&gt; ret = new ArrayList&lt;&gt;();\n        int index = 0;\n        for (int number = 1; number &lt;= n; number++){\n        \n            if (index == target.length) {\n                break;\n            }\n            if (number == target[index]) {\n                ret.add(&quot;Push&quot;);\n                index++;\n            } else {\n                ret.add(&quot;Push&quot;);\n                ret.add(&quot;Pop&quot;);\n            }\n        }\n        \n        return ret;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/submissions/\">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a></h2>\n<p>Medium</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given an array of integers arr.\n\nWe want to select three indices i, j and k where (0 &lt;= i &lt; j &lt;= k &lt; arr.length).\n\nLet&#39;s define a and b as follows:\n\na = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\nb = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\nNote that ^ denotes the bitwise-xor operation.\n\nReturn the number of triplets (i, j and k) Where a == b.\n\n \n\nExample 1:\n\nInput: arr = [2,3,1,6,7]\nOutput: 4\nExplanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\nExample 2:\n\nInput: arr = [1,1,1,1,1]\nOutput: 10\nExample 3:\n\nInput: arr = [2,3]\nOutput: 0\nExample 4:\n\nInput: arr = [1,3,5,7,9]\nOutput: 3\nExample 5:\n\nInput: arr = [7,11,12,9,5,2,7,17,22]\nOutput: 8\n \n\nConstraints:\n\n1 &lt;= arr.length &lt;= 300\n1 &lt;= arr[i] &lt;= 10^8</code></pre></div>\n<p>先做预计算，把所有区间的异或和都算好，然后再找对应的pair。通过map，记录所有异或和相同的区间，然后再这些区间里面找连在一起的</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int countTriplets(int[] arr) {\n        int count = 0;\n        int[][] mem = new int[arr.length][arr.length];\n        // pre sum\n        Map&lt;Integer, List&lt;Pair&lt;Integer, Integer&gt;&gt;&gt; map = new HashMap&lt;&gt;();\n        for (int end = 0; end &lt; arr.length; end++) {\n            go(map, mem, arr, 0, end);\n        }\n        // find pairs\n        for (List&lt;Pair&lt;Integer, Integer&gt;&gt; list : map.values()){\n            // start. num\n            Map&lt;Integer, Integer&gt; right = new HashMap&lt;&gt;();\n            for (Pair&lt;Integer, Integer&gt; pair : list) {\n                right.put(pair.getKey(), right.getOrDefault(pair.getKey(), 0) + 1);\n            }\n            for (Pair&lt;Integer, Integer&gt; pair : list) {\n                count += right.getOrDefault(pair.getValue() + 1, 0);\n            }\n        }\n        \n        return count;\n    }\n    // calculate value from start to end\n    public void go(Map&lt;Integer, List&lt;Pair&lt;Integer, Integer&gt;&gt;&gt; map, int[][] mem, int[] arr, int start, int end) {\n        if (start == end) {\n            mem[start][end] = arr[end];\n\n        } else {\n            go(map, mem, arr, start + 1, end);\n            mem[start][end] = arr[start] ^ mem[start+1][end];\n        }\n        map.putIfAbsent(mem[start][end], new ArrayList&lt;&gt;());\n        map.get(mem[start][end]).add(new Pair&lt;&gt;(start, end));\n    }\n\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/\">1443. Minimum Time to Collect All Apples in a Tree</a></h2>\n<p>Medium</p>\n<p>Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend in order to collect all apples in the tree starting at vertex 0 and coming back to this vertex.</p>\n<p>The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting the vertices fromi and toi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple, otherwise, it does not have any apple.</p>\n<p>Example 1:</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8 \nExplanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.</code></pre></div>\n<p>Example 2:\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\nExplanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  </code></pre></div>\n<p>Example 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Constraints:\n\n1 &lt;= n &lt;= 10^5\nedges.length == n-1\nedges[i].length == 2\n0 &lt;= fromi, toi &lt;= n-1\nfromi &lt; toi\nhasApple.length == n</code></pre></div>\n<p>这个问题就是一个典型的递归问题，因为图形是树而且起点固定，所以简单了很多。简而言之就是找到左子树和右子树的对应值，根据子树是否有苹果递归。格外要注意的就是根节点略有特殊。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int minTime(int n, int[][] edges, List&lt;Boolean&gt; hasApple) {\n        Map&lt;Integer, List&lt;Integer&gt;&gt; way = new HashMap&lt;&gt;();\n\n        for (int[] edge : edges) {\n            way.putIfAbsent(edge[0], new ArrayList&lt;&gt;());\n            way.get(edge[0]).add(edge[1]);\n        }\n        System.out.println(&quot;way &quot; + way);\n\n        int ret = 0;\n        for (int subnode : way.get(0)) {\n            int r = steps(way, subnode, hasApple);\n            ret += r;\n        }\n        return ret;\n    }\n\n    private int steps(Map&lt;Integer, List&lt;Integer&gt;&gt; way, int node, List&lt;Boolean&gt; hasApple) {\n        // 边界条件，如果本身是苹果那么要走两步\n        if (way.get(node) == null) {\n            if (hasApple.get(node)) {\n                return 2;\n            } else {\n                return 0;\n            }\n        }\n        int ret = 0;\n        for (int subnode : way.get(node)) {\n            int r = steps(way, subnode, hasApple);\n            ret += r;\n        }\n\n        // 如果子树有苹果，那么节点本身必然要遍历\n        if (ret &gt; 0) {\n            return ret + 2;\n        } else if (hasApple.get(node)) {\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/\">1444. Number of Ways of Cutting a Pizza</a></h2>\n<p>Hard</p>\n<p>Given a rectangular pizza represented as a rows x cols matrix containing the following characters: ‘A’ (an apple) and ’.’ (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. </p>\n<p>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.</p>\n<p>Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.</p>\n<p>Example 1:\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.</code></pre></div>\n<p>Example 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3\nOutput: 1</code></pre></div>\n<p>Example 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1\nOutput: 1</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Constraints:\n\n1 &lt;= rows, cols &lt;= 50\nrows == pizza.length\ncols == pizza[i].length\n1 &lt;= k &lt;= 10\npizza consists of characters &#39;A&#39; and &#39;.&#39; only.</code></pre></div>\n<p>题目就是要保证每次切的时候两边都有苹果。但是这个判断我们不可能每次都遍历全图算一遍，所以我们必须要预计算减少时间复杂度。如果你直接计算的话，那么所有的区间是有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>个，太大了。但是因为切割方式的特殊，我们每次只去掉左边或者上面的蛋糕，根据这个特性，我们计算的区间可以固定右下角的定点。即我们可以预计算apples[row][col],对于每个apples[i][j],其值的意义为以（i,j）为左上角，右下角为pizza的右下角的这个矩形中有多少个苹果。而且这个递推公式为apples[row][col] = apples[row+1][col] + apples[row][col+1] - apples[row+1][col+1] + {is pizza(i,j) has apple}。那么我们就可以开始切了。最直接粗暴的方式就是dfs，遍历每种可能的切法，并且让每次切的时候都必然能切完。这个要求就是如果现在还剩n刀要切，那么切完剩下的pizza必须要有n个apple。并且我们配上熟悉的DP，加个memory减少时间复杂度。mem[row][col][cut]表示对于左上定点为(row,col)的子pizza，还有n刀要切的时候有多少种切法。实测时间和空间都超过100%，代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int ways(String[] pizza, int k) {\n        int l1 = pizza.length;\n        int l2 = pizza[0].length();\n        int[][] apples = new int[pizza.length][pizza[0].length()];\n        char c = pizza[l1 - 1].charAt(l2 - 1);\n        apples[pizza.length-1][pizza[0].length() - 1] =  c == &#39;A&#39; ? 1 : 0;\n        // last row\n        for (int i = l2 - 2; i &gt;= 0; i-- ) {\n            boolean isApple = pizza[l1 - 1].charAt(i) == &#39;A&#39;;\n            int num = isApple ? 1 : 0;\n            apples[l1-1][i] = num + apples[l1 - 1][i+1];\n        }\n\n        // last col\n        for (int i = l1 - 2; i &gt;= 0; i-- ) {\n            boolean isApple = pizza[i].charAt(l2-1) == &#39;A&#39;;\n            int num = isApple ? 1 : 0;\n            apples[i][l2-1] = num + apples[i+1][l2-1];\n        }\n\n        for (int row = l1 - 2; row &gt;= 0; row--) {\n            for (int col = l2 - 2; col &gt;=0; col--) {\n                int num = pizza[row].charAt(col) == &#39;A&#39; ? 1 : 0;\n                int ret = apples[row+1][col] + apples[row][col+1] - apples[row+1][col+1];\n                apples[row][col] = num + ret;\n            }\n        }\n\n        Integer[][][] mem = new Integer[l1][l2][k+1];\n        return cuts(apples, mem, 0, 0, k - 1);\n    }\n\n    // mem: row, col, cut\n    private int cuts(int[][] apples, Integer[][][] mem, int row, int col, int cut) {\n        if (cut == 0) {\n            return 1;\n        }\n        if (mem[row][col][cut] != null) {\n            return mem[row][col][cut];\n        }\n        int count = apples[row][col];\n\n        int cutsChoice = 0;\n\n        // test horizontal cut\n        for (int i = col + 1; i &lt; apples[0].length; i++) {\n            int rightApples = apples[row][i];\n            if (rightApples &gt;= cut) {\n                // 左边必须有apple\n                if (rightApples == count) {\n                    continue;\n                }\n                cutsChoice+= cuts(apples, mem, row, i, cut - 1);\n                cutsChoice = cutsChoice % 1000000007;\n            } else {\n                // 右边apple已经不够，不用遍历了\n                break;\n            }\n        }\n\n        // test  cut row\n        for (int i = row + 1; i &lt; apples.length; i++) {\n            int downApples = apples[i][col];\n            if (downApples &gt;= cut) {\n                if (downApples == count) {\n                    continue;\n                }\n                cutsChoice+= cuts(apples, mem, i, col, cut - 1);\n                cutsChoice = cutsChoice % 1000000007;\n            } else {\n                break;\n            }\n        }\n        mem[row][col][cut] = cutsChoice;\n\n        return cutsChoice;\n    }\n}</code></pre></div>","frontmatter":{"title":"leetcode contest 188","date":"May 09, 2020","tags":["leetcode","contest"]}}},"pageContext":{"slug":"/leetcode contest 188/","previous":null,"next":{"fields":{"slug":"/leetcode contest 187/"},"frontmatter":{"title":"leetcode contest 187"}}}}}