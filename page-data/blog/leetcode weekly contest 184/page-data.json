{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/leetcode weekly contest 184/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"afd17ad1-51a1-50e6-b566-ea1624d376db","excerpt":"本来想喝着小酒写作业的，刚好看到今天星期六，就顺手做了一下leetcode contest，没想到drunk code如此给力，就趁热打铁把思路写出来了。因为四个题加起来只用了不到一小时，勉强可以认为符合实际的做题时间，算是一种实际面试的模拟吧。 1 String Matchi…","html":"<p>本来想喝着小酒写作业的，刚好看到今天星期六，就顺手做了一下leetcode contest，没想到drunk code如此给力，就趁热打铁把思路写出来了。因为四个题加起来只用了不到一小时，勉强可以认为符合实际的做题时间，算是一种实际面试的模拟吧。</p>\n<h2><a href=\"https://leetcode.com/problems/string-matching-in-an-array/\">1 String Matching in an Array</a></h2>\n<p>Difficulty:Easy </p>\n<p>Given an array of string words. Return all strings in words which is substring of another word in any order. </p>\n<p>String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]\nOutput: [&quot;as&quot;,&quot;hero&quot;]\nExplanation: &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.\n[&quot;hero&quot;,&quot;as&quot;] is also a valid answer.\n\nExample 2:\nInput: words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]\nOutput: [&quot;et&quot;,&quot;code&quot;]\nExplanation: &quot;et&quot;, &quot;code&quot; are substring of &quot;leetcode&quot;.\n\nExample 3:\nInput: words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]\nOutput: []</code></pre></div>\n<p>题目的难度是easy，实际也很简单，最直观的就是两次遍历一个个判断，然后简单优化一下就是按长度从长到短排序，因为短的只能是长的的substring，而且如果a是b的substring，b是c的substring，那么a必定是c的substring。而且题目说没有重复的string，所以可以分成两个集合，一个集合存substrings，一个存nonsubstrings。虽然都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，但是优化之后比较次数会少很多。至于nlogn的暂时没有什么想法，也没有面试官给我hint，所以直接就写了。</p>\n<p>答案：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public List&lt;String&gt; stringMatching(String[] words) {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n        \n        List&lt;String&gt; ret = new LinkedList&lt;&gt;();\n\n        Arrays.sort(words, (x, y) -&gt; y.length() - x.length());\n        \n        for (String word : words) {\n            if (set.stream().anyMatch(ele -&gt; ele.contains(word))) {\n                ret.add(word);\n            } else {\n                set.add(word);\n            }\n        }\n        return ret;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/queries-on-a-permutation-with-key/\">2. Queries on a Permutation With Key</a></h2>\n<p>Difficulty:Medium</p>\n<p>Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:</p>\n<p>In the beginning, you have the permutation P=[1,2,3,…,m].\nFor the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].\nReturn an array containing the result for the given queries.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: queries = [3,1,2,1], m = 5\nOutput: [2,1,2,1] \nExplanation: The queries are processed as follow: \nFor i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \nFor i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \nFor i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \nFor i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \nTherefore, the array containing the result is [2,1,2,1].  \n\nExample 2:\n\nInput: queries = [4,1,2,2], m = 4\nOutput: [3,1,2,0]\n\nExample 3:\n\nInput: queries = [7,5,5,8,3], m = 8\nOutput: [6,5,0,7,5]</code></pre></div>\n<p>题目本身有点绕，但是实际上理解了之后还是比较简单的。如果不考虑优化，就是数组操作而已。理论上重拍如果rangecopy的话，时间复杂度是o(1)，如果能找到一个合适的查找算法让每次查找都是o(1)或者o(lgn)的话，那么会更快，但是时间有限，没想到，所以就用最之间的o(n)的查找，那么总的时间复杂度就是o(nlgn)。</p>\n<p>答案：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int[] processQueries(int[] queries, int m) {\n        int[] r = new int[queries.length];\n        int[] ret = new int[m];\n        for (int i = 0; i&lt; ret.length; i++) {\n            ret[i] = i+1;\n        }\n\n        for (int i = 0; i &lt; queries.length; i++) {\n            int target = queries[i];\n            int index = -1;\n            for (int j = 0; j &lt; ret.length; j++) {\n                if (ret[j] == target) {\n                    index = j;\n                    r[i] = index;\n                    break;\n                }\n            }\n            // 最好是用rangecopy效率高，但是懒得翻api了就直接怼\n            int[] newret = new int[m];\n            newret[0] = target;\n            for (int i1 = 0; i1 &lt; index; i1++) {\n                newret[i1+1] = ret[i1];\n            }\n            for (int i2 = index + 1; i2 &lt; ret.length; i2++) {\n                newret[i2] = ret[i2];\n            }\n            ret = newret;\n        }\n        return r;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/html-entity-parser/\">3. HTML Entity Parser</a></h2>\n<p>Difficulty:Medium\nHTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.</p>\n<p>The special characters and their entities for HTML are:</p>\n<p>Quotation Mark: the entity is ” and symbol character is “.\nSingle Quote Mark: the entity is ’ and symbol character is ‘.\nAmpersand: the entity is &#x26; and symbol character is &#x26;.\nGreater Than Sign: the entity is > and symbol character is >.\nLess Than Sign: the entity is &#x3C; and symbol character is &#x3C;.\nSlash: the entity is ⁄ and symbol character is /.\nGiven the input text string to the HTML parser, you have to implement the entity parser.</p>\n<p>Return the text after replacing the entities by the special characters.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;\nOutput: &quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;\nExplanation: The parser will replace the &amp;amp; entity by &amp;\n\nExample 2:\n\nInput: text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;\nOutput: &quot;and I quote: \\&quot;...\\&quot;&quot;\n\nExample 3:\n\nInput: text = &quot;Stay home! Practice on Leetcode :)&quot;\nOutput: &quot;Stay home! Practice on Leetcode :)&quot;\n\nExample 4:\n\nInput: text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot;\nOutput: &quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;\n\nExample 5:\n\nInput: text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;\nOutput: &quot;leetcode.com/problemset/all&quot;</code></pre></div>\n<p>这个其实也没有什么难度，就是字符串操作。但是实际上我写的时候喝多了点，脑子有点短路，是用最后的<code class=\"language-text\">;</code>做判断是否进入对比的流程。实际上用开始的<code class=\"language-text\">&amp;</code>会更方便些。总的来说就是一个个扫描，如果碰到了<code class=\"language-text\">&amp;</code>，那么就进行对比，符合的话就转换。</p>\n<p>答案：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public String entityParser(String text) {\n        StringBuffer sb = new StringBuffer();\n        int cursor = text.length() - 1;\n        while (cursor &gt;= 0) {\n            if (text.charAt(cursor) != &#39;;&#39;) {\n                sb.insert(0, text.charAt(cursor));\n                cursor--;\n            } else {\n                if (cursor &gt;= 3 &amp;&amp;&quot;&amp;lt&quot;.equals(text.substring(cursor - 3, cursor))) {\n                    sb.insert(0, &quot;&lt;&quot;);\n                    cursor = cursor - 4;\n                } else if (cursor &gt;= 3 &amp;&amp; &quot;&amp;gt&quot;.equals(text.substring(cursor - 3, cursor))) {\n                    sb.insert(0, &quot;&gt;&quot;);\n                    cursor = cursor - 4;\n                } else if (cursor &gt;= 4 &amp;&amp; &quot;&amp;amp&quot;.equals(text.substring(cursor - 4, cursor))) {\n                    sb.insert(0, &quot;&amp;&quot;);\n                    cursor = cursor - 5;\n                } else if (cursor &gt;= 5 &amp;&amp; &quot;&amp;apos&quot;.equals(text.substring(cursor - 5, cursor))) {\n                    sb.insert(0, &quot;&#39;&quot;);\n                    cursor = cursor - 6;\n                } else if (cursor &gt;= 5 &amp;&amp; &quot;&amp;quot&quot;.equals(text.substring(cursor - 5, cursor))) {\n                    sb.insert(0, &quot;\\&quot;&quot;);\n                    cursor = cursor - 6;\n                } else if (cursor &gt;= 6 &amp;&amp; &quot;&amp;frasl&quot;.equals(text.substring(cursor - 6, cursor))) {\n                    sb.insert(0, &quot;/&quot;);\n                    cursor = cursor - 7;\n                } else {\n                    sb.insert(0, text.charAt(cursor));\n                    cursor--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/\">4. Number of Ways to Paint N × 3 Grid</a></h2>\n<p>Difficulty:Hard\nYou have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colours: Red, Yellow or Green while making sure that no two adjacent cells have the same colour (i.e no two cells that share vertical or horizontal sides have the same colour).</p>\n<p>You are given n the number of rows of the grid.</p>\n<p>Return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 10^9 + 7.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: n = 1\nOutput: 12\nExplanation: There are 12 possible way to paint the grid as shown:\n\nExample 2:\n\nInput: n = 2\nOutput: 54\n\nExample 3:\n\nInput: n = 3\nOutput: 246\n\nExample 4:\n\nInput: n = 7\nOutput: 106494\n\nExample 5:\n\nInput: n = 5000\nOutput: 30228214</code></pre></div>\n<p>这个题目有点意思，一看就是一个数学题。本来着色问题是很难的，但是因为他有两个限制，一个是宽度只有3，第二个是颜色只有3个，所以简单了非常多。也是我运气比较好，一开始就想到了一个思路。因为他是3*n的形状，那么填第i行的时候，只需要收到第i-1行的限制。而example告诉我们，一行只有12种可能，那么直接找出12个可能中每个可能所对应的所有下一行的可能就可以以此类推了。</p>\n<p>而且，我们可以进一步简化，因为颜色其实是对等的，所以我们可以直接撇去颜色，思考一个更简化的模型。就是一行着色中只有两种可能，一种是有两种颜色，简称为A模式，一种是有三种颜色，称为B模式。</p>\n<p>假设有XYZ三种颜色。XYZ只代表他们颜色不同，不代表具体的颜色。</p>\n<p>A模式的色彩分布必定为XYX，X和Y为任意不同颜色。其对应的下一行必定为 YXY，YZY，YZX，ZXZ，ZXY，下一行有5中可能，3中是A模式，2种是B模式</p>\n<p>同理，B模式的色彩分布必定是XYZ，其对应的下一行必然为 YXY，YZY，YZX，ZXY。2中A模式，2种B模式。</p>\n<p>那么我们就可以开始递推了。假如涂色涂到了第i行，其中有n中可能为A模式，m种可能为B模式，那么第i+1行有(3n+2m)种可能为A模式，(2n+2m)种可能为B模式。</p>\n<p>所以代码很简单</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int numOfWays(int n) {\n        long a = 6;\n        long b = 6;\n        for (int i = 1; i &lt; n; i++) {\n            long aa = (3 * a + 2 * b) % 1000000007;\n            long bb = (2 * a + 2 * b) % 1000000007;\n            a = aa;\n            b = bb;\n        }\n        return (int)((a+b) % 1000000007) ;\n    }\n}</code></pre></div>","frontmatter":{"title":"leetcode weekly contest 184","date":"April 11, 2020","tags":["leetcode","contest"]}}},"pageContext":{"slug":"/leetcode weekly contest 184/","previous":null,"next":{"fields":{"slug":"/华州留学生驾照指南/"},"frontmatter":{"title":"华州留学生驾照指南"}}}}}