{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/leetcode contest 190/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"1e5f71e2-5adf-514a-8219-29513cee20df","excerpt":"现在才发现那些定时更新的up主真的挺有毅力，我连这种周更都经常会犯懒拖更。这一次的contest也按时写完啦，而且第四题还是比较常规的dp哦。 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence …","html":"<p>现在才发现那些定时更新的up主真的挺有毅力，我连这种周更都经常会犯懒拖更。这一次的contest也按时写完啦，而且第四题还是比较常规的dp哦。</p>\n<h2><a href=\"https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/\">1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</a></h2>\n<p>Easy</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given a sentence that consists of some words separated by a single space, and a searchWord.\n\nYou have to check if searchWord is a prefix of any word in sentence.\n\nReturn the index of the word in sentence where searchWord is a prefix of this word (1-indexed).\n\nIf searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.\n\nA prefix of a string S is any leading contiguous substring of S.\n\n \n\nExample 1:\n\nInput: sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot;\nOutput: 4\nExplanation: &quot;burg&quot; is prefix of &quot;burger&quot; which is the 4th word in the sentence.\nExample 2:\n\nInput: sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot;\nOutput: 2\nExplanation: &quot;pro&quot; is prefix of &quot;problem&quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it&#39;s the minimal index.\nExample 3:\n\nInput: sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot;\nOutput: -1\nExplanation: &quot;you&quot; is not a prefix of any word in the sentence.\nExample 4:\n\nInput: sentence = &quot;i use triple pillow&quot;, searchWord = &quot;pill&quot;\nOutput: 4\nExample 5:\n\nInput: sentence = &quot;hello from the other side&quot;, searchWord = &quot;they&quot;\nOutput: -1\n \n\nConstraints:\n\n1 &lt;= sentence.length &lt;= 100\n1 &lt;= searchWord.length &lt;= 10\nsentence consists of lowercase English letters and spaces.\nsearchWord consists of lowercase English letters.</code></pre></div>\n<p>没什么难度，就是写。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int isPrefixOfWord(String sentence, String searchWord) {\n        String[] strings = sentence.split(&quot; &quot;);\n        for (int i = 0; i &lt; strings.length; i++) {\n            if (strings[i].length() &gt;= searchWord.length() &amp;&amp; strings[i].startsWith(searchWord)) {\n                return i+1;\n            }\n        }\n        return -1;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/\">1456. Maximum Number of Vowels in a Substring of Given Length</a></h2>\n<p>Medium</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given a string s and an integer k.\n\nReturn the maximum number of vowel letters in any substring of s with length k.\n\nVowel letters in English are (a, e, i, o, u).\n\n \n\nExample 1:\n\nInput: s = &quot;abciiidef&quot;, k = 3\nOutput: 3\nExplanation: The substring &quot;iii&quot; contains 3 vowel letters.\nExample 2:\n\nInput: s = &quot;aeiou&quot;, k = 2\nOutput: 2\nExplanation: Any substring of length 2 contains 2 vowels.\nExample 3:\n\nInput: s = &quot;leetcode&quot;, k = 3\nOutput: 2\nExplanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels.\nExample 4:\n\nInput: s = &quot;rhythms&quot;, k = 4\nOutput: 0\nExplanation: We can see that s doesn&#39;t have any vowel letters.\nExample 5:\n\nInput: s = &quot;tryhard&quot;, k = 4\nOutput: 1\n \n\nConstraints:\n\n1 &lt;= s.length &lt;= 10^5\ns consists of lowercase English letters.\n1 &lt;= k &lt;= s.length</code></pre></div>\n<p>典型的滑动窗口，双指针干就完了</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int maxVowels(String s, int k) {\n        int left = 0;\n        int right = k;\n        \n        int now = 0;\n        for (int i = left; i &lt; k; i++) {\n            if (isV(s.charAt(i))) {\n                now++;\n            }\n        }\n        int max = now;\n        \n        \n        while (right &lt; s.length()) {\n            if (isV(s.charAt(right))) {\n                now++;\n            }\n            right++;\n            if (isV(s.charAt(left))) {\n                now--;\n            }\n            left++;\n            max = Math.max(now, max);\n        }\n        return max;\n    }\n\n    private boolean isV(char c) {\n        return c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39;;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/\">1457. Pseudo-Palindromic Paths in a Binary Tree</a></h2>\n<p>Medium</p>\n<p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.</p>\n<p>Return the number of pseudo-palindromic paths going from the root node to leaf nodes.</p>\n<p>Example 1:</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: root = [2,3,1,3,1,null,1]\nOutput: 2 \nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).</code></pre></div>\n<p>Example 2:</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: root = [2,1,1,1,3,null,null,null,null,null,1]\nOutput: 1 \nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).</code></pre></div>\n<p>Example 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: root = [9]\nOutput: 1</code></pre></div>\n<p>Constraints:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">The given binary tree will have between 1 and 10^5 nodes.\nNode values are digits from 1 to 9.</code></pre></div>\n<p>这个题目可以理解为DFS也可以看成是backtrace，就是遍历每一条路径，在遍历的时候记录路径中各个数值的量，只有路径有不超过一个值为奇数才是回文数。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    int lines = 0;\n    int[] count = new int[10];\n    \n    public int pseudoPalindromicPaths (TreeNode root) {\n        walk(root);\n        return lines;\n    }\n    \n    public void walk(TreeNode root) {\n        count[root.val]++;\n        if (root.left != null) {\n            pseudoPalindromicPaths(root.left);\n        }\n        if (root.right != null) {\n            pseudoPalindromicPaths(root.right);\n        }\n        if (root.left == null &amp;&amp; root.right == null) {\n            if (isPseudoP(count)) {\n                lines++;\n            }\n        }\n        count[root.val]--;\n    }\n    \n    private boolean isPseudoP(int[] count) {\n        int oddNum = 0;\n        for (int i = 1; i &lt; count.length; i++) {\n            if (count[i] % 2 == 1) {\n                oddNum++;\n            }\n        }\n        return oddNum &lt;= 1;\n    }\n}</code></pre></div>\n<h2><a href=\"https://leetcode.com/problems/max-dot-product-of-two-subsequences/\">1458. Max Dot Product of Two Subsequences</a></h2>\n<p>Hard</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Given two arrays nums1 and nums2.\n\nReturn the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).\n\n \n\nExample 1:\n\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\nExample 2:\n\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\nExample 3:\n\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n \nConstraints:\n1 &lt;= nums1.length, nums2.length &lt;= 500\n-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></pre></div>\n<p>真的题目做多了会有感觉的，这种subsequence很容易让人想到没有后效性，因为前后的元素关联不大。所以我们可以找找这个递推关系。很自然的，我们可以假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>表示只用list1的前i+1个数，只用list2的前j+1个数，可以得到的最大结果是什么。很自然的，他的最直接的子问题就是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m(i-1,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">m(i,j-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，那么我们就可以分情况了</p>\n<ul>\n<li>情况1，不用list1(i),那么m(i,j) = m(i-1,j)</li>\n<li>情况2，不用list2(j),那么m(i,j) = m(i,j-1)</li>\n<li>情况3，都不用，那么m(i,j) = m(i-1, j-1)</li>\n<li>情况4，配对list1(i) 和 list2（j）,那么m(i,j) = m(i-1,j-1) + l1(i) * l2(j)\n求四个情况的最大值</li>\n</ul>\n<p>公式如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">m(i,j) = max(\n    m(i-1, j),\n    m(i, j-1),\n    m(i-1,j-1),\n    m(i-1,j-1) + l1(i) * l2(j)\n)</code></pre></div>\n<p>公式在手，dp我有，之后注意一下边界条件就行。代码如下。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution {\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n        dp[][] = new int[nums1.length][mnums2.length];\n        for (int i = 0; i &lt; nums1.length; i++) {\n            for (int j = 0; j &lt; nums2.length; j++) {\n                dp[i][j] = A[i] * B[j];\n                if (i &gt; 0 &amp;&amp; j &gt; 0) dp[i][j] += Math.max(dp[i-1][j-1], 0);\n                if (i &gt; 0) dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\n                if (j &gt; 0) dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);\n            }\n        }\n        return dp[n-1][m-1];\n    }\n}</code></pre></div>","frontmatter":{"title":"leetcode contest 190","date":"May 27, 2020","tags":["leetcode","contest"]}}},"pageContext":{"slug":"/leetcode contest 190/","previous":null,"next":{"fields":{"slug":"/leetcode contest 189/"},"frontmatter":{"title":"leetcode contest 189"}}}}}